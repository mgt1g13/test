/*******************************************************************************
 * Copyright (c) 2011 University of Southampton.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package ac.soton.eventb.emf.components.transformation.commands;

import java.util.Collections;
import java.util.Iterator;
import java.util.regex.Pattern;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IAdaptable;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.transaction.TransactionalEditingDomain;
import org.eclipse.gef.commands.Command;
import org.eclipse.gmf.runtime.common.core.command.CommandResult;
import org.eclipse.gmf.runtime.diagram.ui.commands.ICommandProxy;
import org.eclipse.gmf.runtime.emf.commands.core.command.AbstractTransactionalCommand;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.ui.handlers.HandlerUtil;
import org.eventb.core.IMachineRoot;
import org.eventb.emf.core.Attribute;
import org.eventb.emf.core.EventBElement;
import org.eventb.emf.core.machine.Action;
import org.eventb.emf.core.machine.Event;
import org.eventb.emf.core.machine.Guard;
import org.eventb.emf.core.machine.Invariant;
import org.eventb.emf.core.machine.Machine;
import org.eventb.emf.core.machine.Variable;

import ac.soton.eventb.emf.components.ComponentsPackage;
import ac.soton.eventb.emf.components.transformation.TransformationPlugin;


/**
 * Deletes all the elements generated by components extension.
 * 
 * @author vitaly
 *
 */
public class DeleteGeneratedByComponentsCommand extends AbstractHandler {

	/**
	 * @author vitaly
	 *
	 */
	public class DeleteGeneratedCommand extends
			AbstractTransactionalCommand {

		private URI machineURI;
		private String generatorID;

		/**
		 * @param machineURI
		 * @param generatorID
		 */
		public DeleteGeneratedCommand(URI machineURI,
				String generatorID) {
			super(TransactionalEditingDomain.Factory.INSTANCE.createEditingDomain(), "Delete all generated by extension", null);
			this.machineURI = machineURI;
			this.generatorID = generatorID;
		}

		@Override
		protected CommandResult doExecuteWithResult(IProgressMonitor monitor,
				IAdaptable info) throws ExecutionException {
			monitor.beginTask("Deleting generated elements", IProgressMonitor.UNKNOWN);
			
			TransactionalEditingDomain editingDomain = getEditingDomain();
			
			try {
				Resource resource = editingDomain.getResourceSet().getResource(machineURI, true);
				
				if (resource != null && resource.isLoaded()) {
					Machine machine = (Machine) resource.getContents().get(0);
					cleanMachine(machine, generatorID);
					resource.save(Collections.emptyMap());
				}
			} catch (Exception e) {
				return CommandResult.newErrorCommandResult(e);
			} finally {
				monitor.done();
			}
			
			return CommandResult.newOKCommandResult();
		}

		/**
		 * Clean machine from generated elements.
		 * 
		 * @param machine
		 * @param generatorID
		 */
		private void cleanMachine(Machine machine,
				String generatorID) {
			
			// clean 
//			for (Iterator<EObject> it = machine.eContents().iterator(); it.hasNext(); ) {
//				EObject eObject = it.next();
//				if (eObject instanceof EventBElement && isGenerated((EventBElement)eObject, generatorID))
//					it.remove();
//			}
			
			// clean variables
			for (Iterator<Variable> it = machine.getVariables().iterator(); it.hasNext(); ) {
				Variable var = it.next();
				if (isGenerated(var, generatorID))
					it.remove();
			}
			
			// clean invariants
			for (Iterator<Invariant> it = machine.getInvariants().iterator(); it.hasNext(); ) {
				Invariant inv = it.next();
				if (isGenerated(inv, generatorID))
					it.remove();
			}
			
			// clean invariants
			for (Iterator<Event> it = machine.getEvents().iterator(); it.hasNext(); ) {
				Event inv = it.next();
				if (isGenerated(inv, generatorID))
					it.remove();
			}
			
			// clean events
			for (Event event : machine.getEvents())
				cleanEvent(event, generatorID);
		}

		/**
		 * Cleans event from generated elements.
		 * 
		 * @param event
		 * @param generatorID
		 */
		private void cleanEvent(Event event, String generatorID) {
			// clean guards
			for (Iterator<Guard> it = event.getGuards().iterator(); it.hasNext(); ) {
				Guard guard = it.next();
				if (isGenerated(guard, generatorID))
					it.remove();
			}
			
			// clean actions
			for (Iterator<Action> it = event.getActions().iterator(); it.hasNext(); ) {
				Action action = it.next();
				if (isGenerated(action, generatorID))
					it.remove();
			}
		}

		/**
		 * Returns true if generated by generator of ID.
		 * 
		 * @param element
		 * @param generatorID
		 * @return
		 */
		private boolean isGenerated(EventBElement element, String generatorID) {
			Attribute attribute = element.getAttributes().get("org.eventb.emf.persistence.generator_ID");
			return attribute != null && Pattern.matches(generatorID + ".*", String.valueOf(attribute.getValue()));
		}

	}

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		ISelection selection = HandlerUtil.getCurrentSelectionChecked(event);
		if (selection instanceof IStructuredSelection) {
			Object element = ((IStructuredSelection) selection).getFirstElement();
			if (element instanceof IMachineRoot) {
				IMachineRoot machineRoot = (IMachineRoot) element;
				IFile file = machineRoot.getResource();
					
				if (file != null && file.exists()) {
					URI machineURI = URI.createPlatformResourceURI(file.getFullPath().toString(), true);
					
					try {
						Command command = new ICommandProxy(new DeleteGeneratedCommand(machineURI, ComponentsPackage.COMPONENTS_EXTENSION_ID));
						if (command.canExecute())
							command.execute();
					} catch (Exception e) {
						TransformationPlugin.getDefault().logError("Refinement failed", e);
					}
				}
			}
		}
		return null;
	}

}
