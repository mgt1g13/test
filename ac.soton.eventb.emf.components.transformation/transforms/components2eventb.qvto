import libraries.cleanup;
import libraries.connectors;
import libraries.components;
import libraries.strings;

modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype components uses components('http://soton.ac.uk/models/eventb/components');

transformation components2eventb(inout inoutModel:eventb, in inComponent:components);


/*
 * The main transformation transforms all component content of a machine to eventb.
 */
main() {
	inoutModel.rootObjects()[eventb::machine::Machine]->map rootAbstractComponent2eventb(inComponent.rootObjects()![components::AbstractComponent]);
}

/*
 * Transforms a root level abstract component to eventb.
 */
mapping inout eventb::machine::Machine::rootAbstractComponent2eventb(in rootAbstractComponent : components::AbstractComponent) {
	var generatorID : String := rootAbstractComponent.getExtensionID();
	var initEvent : eventb::machine::Event := events[name = INIT]->first();
	var channelUnion : String := rootAbstractComponent.getChannelUnion();
	self.map machine2nonGeneratedMachine(generatorID);
	
	variables := (
				rootAbstractComponent.map rootAbstractComponent2specificVariable(CT_NAME, generatorID)->asSequence() 	)->union(
			 	rootAbstractComponent.map rootAbstractComponent2specificVariable(ST_NAME, generatorID)->asSequence()	)->union(
				rootAbstractComponent.map abstractComponent2variables(generatorID)	)->union(
				variables->asSequence()
				);
				
	invariants := (
				rootAbstractComponent.map rootAbstractComponent2specificInvariant(CT_NAME, CT_TYPE_PRED, generatorID)->asSequence() )->union(
			 	rootAbstractComponent.map rootAbstractComponent2specificInvariant(ST_NAME, ST_TYPE_PRED, generatorID)->asSequence()	)->union(
				rootAbstractComponent.map abstractComponent2typeInvariants(generatorID)	)->union(
				invariants->asSequence()
				);

	initEvent.actions := (
				rootAbstractComponent.map rootAbstractComponent2specificInitAction(CT_NAME, CT_INIT_EXPR, initEvent, generatorID)->asSequence()	)->union(
			 	rootAbstractComponent.map rootAbstractComponent2specificInitAction(ST_NAME, ST_INIT_EXPR, initEvent, generatorID)->asSequence()	)->union(
				rootAbstractComponent.map abstractComponent2initActions(initEvent, generatorID) )->union(
				initEvent.actions -> asSequence()
				);
	
	events := (
				events->asSequence()	)->union(
				rootAbstractComponent.map rootAbstractComponent2timerEvent(channelUnion, generatorID)->asSequence()
				);
}






/*
 * Transforms the root abstract connector to a specific, named, variable.
 */
mapping components::AbstractComponent::rootAbstractComponent2specificVariable(in vname : String, in generatorID : String) : eventb::machine::Variable
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine)} {
	name := vname;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}


/*
 * Transforms the root abstract connector to a specific, invariant.
 */
mapping components::AbstractComponent::rootAbstractComponent2specificInvariant(in vname : String, in pred : String, in generatorID : String) : eventb::machine::Invariant
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine)} {
	name := vname + ".type";
	predicate := pred;	
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}


/*
 * Transforms the root abstract connector to a specific, initialisation action.
 */
mapping components::AbstractComponent::rootAbstractComponent2specificInitAction(in vname : String, in expr : String, in initEvent : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine) and not initEvent.containsAction(vname + ".init")} {
	name := vname + ".init";
	action := expr;	
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}


/*
 * Transforms the root abstract connector to a timer event.
 */
mapping components::AbstractComponent::rootAbstractComponent2timerEvent(in channelUnion : String, in generatorID : String) : eventb::machine::Event
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine)} {
	name := TE_NAME;
	parameters := self.map rootAbstractComponent2specificParameter(TE_PARAM_NAME, generatorID)->asSequence();
	guards := (
				self.map rootAbstractComponent2specificGuard(TE_GD1_NAME,TE_GD1_PRED, generatorID)->asSequence() 	)->union(
				self.map rootAbstractComponent2specificGuard(TE_GD2_NAME,TE_GD2_PRED, generatorID)->asSequence() 	)->union(
				self.components[components::AbstractComponent].map abstractComponent2timerGuards(channelUnion, result, generatorID)
				);
	actions := (
				self.map rootAbstractComponent2specificAction(TE_AC1_NAME,TE_AC1_EXPR, generatorID)->asSequence() 	)->union(
				self.map rootAbstractComponent2specificAction(TE_AC2_NAME,TE_AC2_EXPR, generatorID)->asSequence() 	)->union(
				self.components[components::AbstractComponent].map abstractComponent2timerActions(result, generatorID)
				);				
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}


/*
 * Transforms the root abstract connector to a specific, named, parameter.
 */
mapping components::AbstractComponent::rootAbstractComponent2specificParameter(in pname : String, in generatorID : String) : eventb::machine::Parameter
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine)} {
	name := pname;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms the root abstract connector to a specific, guard.
 */
mapping components::AbstractComponent::rootAbstractComponent2specificGuard(in gname : String, in pred : String, in generatorID : String) : eventb::machine::Guard
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine)} {
	name := gname;
	predicate := pred;	
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms the root abstract connector to a specific, action.
 */
mapping components::AbstractComponent::rootAbstractComponent2specificAction(in aname : String, in expr : String, in generatorID : String) : eventb::machine::Action
	when {self.eContainer().oclIsTypeOf(eventb::machine::Machine)} {
	name := aname;
	action := expr;	
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}


/*
 * Transforms root abstract component to an Initialisation Event augmented as required with e.g. Actions.
 * 
 *
mapping components::AbstractComponent::rootAbstractComponent2augmentedInitEvent(inout initEvent : eventb::machine::Event, in generatorID : String) {
	initEvent.actions := self[components::Component].map abstractComponent2initActions(initEvent, generatorID) ->
			union(initEvent.actions);
}
*/


///// An alternative way to handle initialisation Event.
/**
 * Transforms root abstract component to an Initialisation Event augmented as required with e.g. Actions.
 * 
 *
mapping components::AbstractComponent::rootAbstractComponent2augmentedInitEvent(in generatorID : String) {
	self.eContainer().oclAsType(eventb::machine::Machine).events[name = INIT].map initEvent2augmentedInitEvent(self, generatorID);
}


/*
 * Transforms initialisation event to the same event augmented with initialisation actions etc. as required by an abstract component.
 *
mapping inout eventb::machine::Event::initEvent2augmentedInitEvent(in abstractComponent : components::AbstractComponent, in generatorID : String) {
	self.actions := abstractComponent[components::AbstractComponent].map abstractComponent2initActions(self, generatorID)->
		union(self.actions);
}

/*
 * Transforms initialisation event to the same event augmented with initialisation actions required by a connector.
 *
mapping components::AbstractComponent::abstractComponent2initActions(in initEvent : eventb::machine::Event, in generatorID : String) : Sequence(eventb::machine::Action) {
	init {
		result := 
			self.connectors[components::Connector].map connector2initAction(initEvent, generatorID)->asSequence()
			->union(	//deal with connectors in nested components by recursion
				self.components.map abstractComponent2initActions(initEvent, generatorID)->flatten() 
			);
	}
}
**/
/**/