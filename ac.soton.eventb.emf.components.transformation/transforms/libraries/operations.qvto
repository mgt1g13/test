import util;
import strings;

modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype components uses components('http://soton.ac.uk/models/eventb/components');
	
library operations;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Operations
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms an abstract component operation to a sequence of variables.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2variables(in generatorID : String) : Sequence(eventb::machine::Variable) {
	init {
		result := (
			self[components::AbstractComponentOperation].map abstractComponentOperation2synchVariable(generatorID)->asSequence() )->union(
			self[components::AbstractComponentOperation].map abstractComponentOperation2wakeupVariable(generatorID)->asSequence() //)->union(
			);
	}
}

/*
 * Transforms an abstract component operation to a sequence of type invariants.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2typeInvariants(in generatorID : String) : Sequence(eventb::machine::Invariant) {
	init {
		result := (
			self[components::AbstractComponentOperation].map abstractComponentOperation2synchTypeInvariant(generatorID)->asSequence() )->union(
			self[components::AbstractComponentOperation].map abstractComponentOperation2wakeupTypeInvariant(generatorID)->asSequence() //)->union(
			);
	}
}

/*
 * Transforms an abstract component operation to a sequence of initialisation actions.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2initActions(in event : eventb::machine::Event, in generatorID : String) : Sequence(eventb::machine::Action) {
	init {
		result := (
			self[components::AbstractComponentOperation].map abstractComponentOperation2synchInitAction(event, generatorID)->asSequence() )->union(
			self[components::AbstractComponentOperation].map abstractComponentOperation2wakeupInitAction(event, generatorID)->asSequence() //)->union(
			);
	}
}


//////////////////// Operation Synch Variable //////////////////////

/*
 * Transforms an abstract operation to a synch variable.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2synchVariable(in generatorID : String) : eventb::machine::Variable
	{
	name := OS_NAME.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms an abstract operation to a type invariant.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2synchTypeInvariant(in generatorID : String) : eventb::machine::Invariant
	{
	name := OS_NAME.replace(PH_OPN,self.label)+".type";
	predicate := OS_TYPE_PRED.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms an abstract operation to its initialisation action.
 * Skips transformation if event is extended and contains the action already.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2synchInitAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
when { not event.containsAction(OS_NAME.replace(PH_OPN,self.label) + ".init") } {
	name := OS_NAME.replace(PH_OPN,self.label) + ".init";
	action := OS_FALSE_EXPR.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////// Self Wakeup Variable //////////////////////
/*
 * Transforms an abstract operation to a wakeup variable.
 * skips transformation if operation is not a self wake
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2wakeupVariable(in generatorID : String) : eventb::machine::Variable
	when {self.oclIsKindOf(components::SelfWake)}{
	name := OW_NAME.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms an abstract operation to a wakeup type invariant.
 * skips transformation if operation is not a self wake
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2wakeupTypeInvariant(in generatorID : String) : eventb::machine::Invariant
	when {self.oclIsKindOf(components::SelfWake)}{
	name := OW_NAME.replace(PH_OPN,self.label)+".type";
	predicate := OW_TYPE_PRED.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms an abstract operation to its wakeup initialisation action.
 * skips transformation if operation is not a self wake
 * Skips transformation if event is extended and contains the action already.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2wakeupInitAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
when {self.oclIsKindOf(components::SelfWake) and not event.containsAction(OS_NAME.replace(PH_OPN,self.label) + ".init") } {
	name := OW_NAME.replace(PH_OPN,self.label) + ".init";
	action := OW_INIT_EXPR.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////// Timer Guards and Actions //////////////////////

/*
 * Transforms an abstract operation to its timer guard.
 * Skips transformation if event is extended and contains the guard already.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2timerGuard(in channelUnion : String, in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
when {not event.containsAction(TE_GD3_NAME.replace(PH_OPN,self.label)) } {
	name := TE_GD3_NAME.replace(PH_OPN,self.label);
	predicate := TE_GD3A_PRED.replace(PH_OPN,self.label);
	if not self.oclIsKindOf(components::Method) then 
		predicate := predicate+ TE_GD3B_PRED.replace(PH_OPN,self.label).replace(PH_CON_UNION,channelUnion)
	endif;
	if self.oclIsKindOf(components::SelfWake) then
		predicate := predicate.replace(PH_TE_GD3C_PRED,TE_GD3C_PRED.replace(PH_OPN,self.label))
	else
		predicate := predicate.replace(PH_TE_GD3C_PRED,"")
	endif;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms an abstract operation to its timer action.
 * Skips transformation if event is extended and contains the action already.
 */
mapping components::AbstractComponentOperation::abstractComponentOperation2timerAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
when {not event.containsAction(TE_AC3_NAME.replace(PH_OPN,self.label)) } {
	name := TE_AC3_NAME.replace(PH_OPN,self.label);
	action := TE_AC3_EXPR.replace(PH_OPN,self.label);
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////// Elaboration of Events /////////////////////////

/*
 * Transforms an operation by elaborating events with guards and actions.
 */
mapping components::AbstractComponentOperation::operation2elaboratedEvents(in generatorID : String) {
	self.elaborates[name <> INIT].map event2elaboratedEvent(self, generatorID);
}

/*
 * Transforms event to same event augmented with guard and enter actions.
 * Generates guard and enter actions from transition and adds to event.
 */
mapping inout eventb::machine::Event::event2elaboratedEvent(in operation : components::AbstractComponentOperation, in generatorID : String) {
	/*self.parameters := (
				operation[components::PortWake].receives.map dataPacket2connectorReceiveParameter(self, generatorID)->asSequence() )->union(
				self.parameters->asSequence()
				);*/
	self.guards := (
				operation.map element2specifiedGuard(OS_GUARD_NAME.replace(PH_OPN,self.name), OS_FALSE_PRED.replace(PH_OPN,self.name), self, generatorID)->asSequence() )->union(
				operation[components::PortWake].receives.map dataPacket2connectorReceiveGuard(self, generatorID)->asSequence() )->union(
				operation[components::PortWake].map operation2newValueGuard(self, generatorID)->asSequence() )->union(
				self.guards->asSequence()
				);
	self.actions := (
				operation.map element2specifiedAction(OS_ACTION_NAME.replace(PH_OPN,self.name), OS_TRUE_EXPR.replace(PH_OPN,self.name), self, generatorID)->asSequence() )->union(
				operation.call.map method2methodCallAction(self, generatorID)->asSequence() )->union(
				operation.sends.map delayedDataPacket2connectorSendAction(self, generatorID)->asSequence() )->union(
				operation[components::SelfWake].map selfWake2selfWakeAction(self, generatorID)->asSequence() )->union(				//transition.target.externalise()[statemachines::AbstractState].map targetAbstractState2enterActions(self, transition, generatorID)->
				operation.map operation2synchTimesAction(self, generatorID)->asSequence() )->union(
				self.actions->asSequence()
				);
}

/*
 * Transforms an element to a specified, guard.
 */
mapping eventb::EventBElement::element2specifiedGuard(in gname : String, in pred : String, in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
	when {not event.containsGuard(gname)} {
	name := gname;
	predicate := pred;	
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms an element to a specified, action.
 */
mapping eventb::EventBElement::element2specifiedAction(in aname : String, in expr : String, in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
	when {not event.containsAction(aname)} {
	name := aname;
	action := expr;	
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms a data packet to a guard to trigger when the value is received on the connector.
 */
mapping components::DataPacket::dataPacket2connectorReceiveGuard(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
	{init{
		result :=  self.map element2specifiedGuard(
			CONNECTORRECV_GUARD_NAME.replace(PH_CON,self.connector.getName()), 
			CONNECTORRECV_GUARD.replace(PH_CON,self.connector.getName()).replace(PH_VAL,self.value), 
			event, generatorID);
	}
	}


/*
 * Transforms a called method operation to an action to call that method.
 */
mapping components::Method::method2methodCallAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
	{init{
		result :=  self.map element2specifiedAction(METHODCALL_ACTION_NAME.replace(PH_OPN,self.label), OS_FALSE_EXPR.replace(PH_OPN,self.label), event, generatorID);
		//would prefer not use self.label ... it should use event.name but on the events elaborated by self
	}
}

/*
 * Transforms a delayed data packet to an action to send that data on a connector with the specified delay.
 */
mapping components::DelayedDataPacket::delayedDataPacket2connectorSendAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
	{init{
		result :=  self.map element2specifiedAction(
			CONNECTORSEND_ACTION_NAME.replace(PH_CON,self.connector.getName()), 
			CONNECTORSEND_ACTION.replace(PH_CON,self.connector.getName()).replace(PH_DLY,self.delay.toString()).replace(PH_VAL,self.value), 
			event, generatorID);
	}
}

/*
 * Transforms a delayed data packet to an action to send that data on a connector with the specified delay.
 */
mapping components::SelfWake::selfWake2selfWakeAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
	{init{
		result :=  self.map element2specifiedAction(
			SELFWAKE_ACTION_NAME, 
			SELFWAKE_ACTION.replace(PH_OPN,event.name).replace(PH_DLY,self.selfDelay.toString()), 
			event, generatorID);
	}
}

/*
 * Transforms an abstract operation to an action to update the synch_times variable.
 */
mapping components::AbstractComponentOperation::operation2synchTimesAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
	when {self.oclIsKindOf(components::SelfWake) or self.sends->size()>0}
	{init{
	result :=  self.map element2specifiedAction(
			ST_UPDATE_ACTION_NAME, 
			ST_UPDATE_ACTION.replace(PH_SYNCHS, self.getSynchs()), 
			event, generatorID); 
	}
}

helper components::AbstractComponentOperation::getSynchs() : String {
	var separator : String := ",";
	var string : String := "";
	var n : Integer := 1;
	var size : Integer := self.sends->size();
	while (n <= size) {
		string := string + (CT_NAME+B_PLUS+self.sends->at(n).delay.toString());
		n := n + 1;
		if n <= size then string := string + separator endif;
	};
	if (self.oclIsKindOf(components::SelfWake)) then {
		if string.size()>0 then string := string+separator endif;
		string := string + (CT_NAME+B_PLUS+self[components::SelfWake].selfDelay->asSequence()->at(1).toString());} 
	endif;	
	return string;
}

/*
 * Transforms an abstract operation to an action to update the synch_times variable.
 */
mapping components::PortWake::operation2newValueGuard(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
	when {self.receives->size()>0}
	{init{
	result :=  self.map element2specifiedGuard(
			NEWVAL_GUARD_NAME, 
			NEWVAL_GUARD.replace(PH_CON_UNION, self.getConnectorUnion()), 
			event, generatorID); 
	}
}

helper components::PortWake::getConnectorUnion() : String {
	var separator : String := " "+B_UNION+" ";
	var string : String := "";
	var n : Integer := 1;
	var size : Integer := self.receives->size();
	while (n <= size) {
		string := string + (self.receives->at(n).connector.getName());
		n := n + 1;
		if n <= size then string := string + separator endif;
	};
	return string;
}

