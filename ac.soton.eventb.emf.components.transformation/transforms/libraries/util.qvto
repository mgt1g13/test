import eventBSymbols;
modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype components uses components('http://soton.ac.uk/models/eventb/components');

library util;

// index string used for counter
property index : String = "index";

// generator id key
property GENERATOR_ID_KEY : String = "org.eventb.emf.persistence.generator_ID";

// initialisation event name
property INIT : String = "INITIALISATION";


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Query and helper rules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Returns if eventB element is generated or not.
 */
query eventb::EventBElement::isGenerated(in generatorID : String) : Boolean {
	return self.generated = true
		and self.attributes->exists(key = GENERATOR_ID_KEY)
		and self.attributes![key = GENERATOR_ID_KEY].value.value = generatorID;
}

/*
 * Returns 'generated' attribute.
 */
helper getGeneratedAttr(in generatorID : String) : StringToAttributeMapEntry {
	return object StringToAttributeMapEntry {
		key := GENERATOR_ID_KEY;
		value := object Attribute {
			type := AttributeType::String;
			value := generatorID;
		}
	}
}

/*
 * Returns original string surrounded by curly brackets.
 */
helper String::asSet() : String {
	return B_LBRC + self + B_RBRC;
}

/*
 * Returns original string surrounded by parentheses.
 */
helper String::parenthesize() : String {
	return B_LPAR + self + B_RPAR;
}

/*
 * Returns string representation of a sequence of strings, separated by separator.
 */
helper Sequence(String)::toString(in separator : String) : String {
	var string : String := '';
	var n : Integer := 1;
	var size : Integer := self->size();
	while (n <= size) {
		string := string + self->at(n);
		n := n + 1;
		if n <= size then string := string + separator endif;
	};
	return string;
}

/*
 * Returns extension id of abstract statemachine if it's an abstract extension.
 */
helper components::AbstractComponent::getExtensionID() : String {
	return if self.oclIsKindOf(eventb::AbstractExtension)
		then self.oclAsType(eventb::AbstractExtension).extensionId
		else null
		endif;
}

/*
 * Returns the name of an abstract connector.
 */
helper components::AbstractConnector::getName() : String {
	return
	if (self.oclIsTypeOf(components::Connector)) 
	then self.oclAsType(components::Connector).name 
	else if (self.oclIsTypeOf(components::InheritedConnector))
	then self.oclAsType(components::InheritedConnector).label 
	else "<undefined>"
	endif endif;
}
/*
 * Returns the name of an abstract operation.
 */
helper components::AbstractComponentOperation::getName() : String {
	return
	if (self.oclIsTypeOf(eventb::EventBNamed)) 
	then self.oclAsType(eventb::EventBNamed).name 
	else if (self.oclIsTypeOf(components::InheritedConnector))
	then self.oclAsType(components::InheritedConnector).label 
	else "<undefined>"
	endif endif;
}

/*
 * Returns true if event and its extensions contain a guard of specified label.
 */
query eventb::machine::Event::containsGuard(in label : String) : Boolean {
	return self.guards->exists(name = label) or
		(self.extended and self._refines->first().containsGuard(label));
}

/*
 * Returns true if event and its extensions contain an action of specified label.
 */
query eventb::machine::Event::containsAction(in label : String) : Boolean {
	return self.actions->exists(name = label) or
		(self.extended and self._refines->first().containsAction(label));
}

helper components::AbstractComponent::getChannelUnion() : String {
	var separator : String := " "+B_UNION+" ";
	var string : String := '';
	var n : Integer := 1;
	var size : Integer := self.connectors->size();
	while (n <= size) {
		string := string + (self.connectors->at(n).getName());
		n := n + 1;
		if n <= size then string := string + separator endif;
	};
	n := 1;
	size := self.components->size();
	while (n <= size) {
		var substring : String := self.components->at(n).getChannelUnion();
		if string.size()>0 and substring.size()>0 then string := string+separator endif;
		string := string+substring;
		n := n + 1;
	};	
	return string;
}

