modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

transformation statemachines2eventb(inout inoutModel:eventb);

// generator id key
property generatorID : String = "org.eventb.emf.persistence.generator_ID";
// current generator id
property id : String = "ac.soton.eventb.statemachines";

property INIT : String = "INITIALISATION";

property B_EQ : String = " = ";
property B_BEQ : String = " ≔ ";
property B_IN : String = " ∈ ";
property B_BOOL : String = "BOOL";
property B_TRUE : String = "TRUE";
property B_FALSE : String = "FALSE";
property B_NOT : String = " ¬ ";
property B_AND : String = " ∧ ";
property B_OR : String = " ∨ ";
property B_LPAR : String = "(";
property B_RPAR : String = ")";
property B_LBRC : String = "{";
property B_RBRC : String = "}";
property B_COM : String = ", ";
property B_IMPL : String = " ⇒ ";
property B_UNION : String = " ∩ ";


main() {
	inoutModel.rootObjects()[eventb::machine::Machine]->map iumlb2eventb();
}

/*
 * Transforms iumlb to eventb.
 */
mapping inout eventb::machine::Machine::iumlb2eventb() {
	variables := extensions[statemachines::AbstractStatemachine].map abstractStatemachine2variables()->union(variables->reject(isGenerated())->asSequence());
	invariants := extensions[statemachines::AbstractStatemachine].map abstractStatemachine2typeInvariants()->
		union(extensions[statemachines::AbstractStatemachine].map abstractStatemachine2partitionInvariants())->
		union(extensions[statemachines::AbstractStatemachine].map abstractStatemachine2constraintInvariants())->
		union(invariants->reject(isGenerated())->asSequence());
	events![name = INIT].actions := extensions[statemachines::AbstractStatemachine].map abstractStatemachine2initActions()->
		union(events![name = INIT].actions->reject(isGenerated())->asSequence());
}

/*
 * Transforms abstract statemachine to variables.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2variables() : Sequence(eventb::machine::Variable) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2variables();
	}
}

/*
 * Transforms abstract state to variables.
 */
mapping statemachines::AbstractState::abstractState2variables() : Sequence(eventb::machine::Variable) {
	init {
		result := self.map abstractState2variable()->asSequence()->
			union(self.statemachines[statemachines::AbstractStatemachine].map abstractStatemachine2variables()->flatten());
	}
}

/*
 * Transforms abstract state to variable.
 */
mapping statemachines::AbstractState::abstractState2variable() : eventb::machine::Variable {
	name := self.getName();
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract statemachine to type invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2typeInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2typeInvariants();
	}
}

/*
 * Transforms abstract state to type invariants.
 */
mapping statemachines::AbstractState::abstractState2typeInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self![statemachines::State].map state2typeInvariant()->asSequence()->
			union(self.statemachines[statemachines::AbstractStatemachine].map abstractStatemachine2typeInvariants()->flatten());
	}
}

/*
 * Transforms state to type invariant.
 */
mapping statemachines::State::state2typeInvariant() : eventb::machine::Invariant {
	name := self.name + ".type";
	predicate := self.name + B_IN + B_BOOL;
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract statemachine to partiotion invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2partitionInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self![statemachines::Statemachine].map statemachine2partitionInvariant()->asSequence()->
			union(self.nodes[statemachines::AbstractState].map abstractState2partitionInvariants()->flatten());
	}
}

/*
 * Transforms statemachine to partition invariant.
 * Only constructs an invariant if there is more than one state in a statemachine.
 */
mapping statemachines::Statemachine::statemachine2partitionInvariant() : eventb::machine::Invariant
	when { self.nodes[statemachines::State]->size() > 1 }
{
	name := self.name + ".partitionedStates";
	predicate := "partition" + (B_TRUE.asSet() + B_COM + self.getStatePartiotions()->toString(B_COM)).parenthesize();
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract state to partition invariants.
 */
mapping statemachines::AbstractState::abstractState2partitionInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.statemachines[statemachines::AbstractStatemachine].map abstractStatemachine2partitionInvariants();
	}
}

/*
 * Transforms abstract statemachine to constraint invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2constraintInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2constraintInvariants();
	}
}

/*
 * Transforms abstract state to constraint invariants.
 */
mapping statemachines::AbstractState::abstractState2constraintInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self![statemachines::State].map state2constraintInvariants()->
			union(self.statemachines[statemachines::AbstractStatemachine].map abstractStatemachine2constraintInvariants()->flatten());
	}
}

/*
 * Transforms state to constraint invariants.
 */
mapping statemachines::State::state2constraintInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.constraints->collect(c | object eventb::machine::Invariant {
			name := c.name;
			theorem := c.theorem;
			predicate := (self.name + B_EQ + B_TRUE).parenthesize() + B_IMPL + c.predicate.parenthesize();
			generated := true;
			attributes += getGeneratedAttr();
		});
	}
}

/*
 * Transforms abstract statemachine to state variable initialisation actions.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2initActions() : Sequence(eventb::machine::Action) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2initActions();
	}
}

/*
 * Transforms abstract state to state variable initialisation actions.
 */
mapping statemachines::AbstractState::abstractState2initActions() : Sequence(eventb::machine::Action) {
	init {
		result := self.map abstractState2initAction()->asSequence()->
			union(self.statemachines[statemachines::AbstractStatemachine].map abstractStatemachine2initActions());
	}
}

/*
 * Transforms abstract state to its variable initialisation action.
 * Initialises variable with TRUE if there is an incoming transition
 * that elaborates INITIALISATION event, or with FALSE otherwise.
 */
mapping statemachines::AbstractState::abstractState2initAction() : eventb::machine::Action {
	name := self.getName() + ".init";
	action := self.getName() + B_BEQ + if self.incoming.elaborates.name->includes(INIT) then B_TRUE else B_FALSE endif;
	generated := true;
	attributes += getGeneratedAttr();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// query and helper rules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Returns if eventB element is generated or not.
 */
query eventb::EventBElement::isGenerated() : Boolean {
	return self.generated = true and self.attributes![key = generatorID].value.value = id;
}

/*
 * Returns 'generated' attribute.
 */
helper getGeneratedAttr() : StringToAttributeMapEntry {
	return object StringToAttributeMapEntry {
		key := generatorID;
		value := object Attribute {
			type := AttributeType::String;
			value := id;
		}
	}
}

/*
 * Returns the name of an abstract state.
 */
helper statemachines::AbstractState::getName() : String {
	return if (self.oclIsTypeOf(statemachines::State)) 
	then self.oclAsType(statemachines::State).name 
	else self.oclAsType(statemachines::RefinedState).label endif;
}

/*
 * Returns a sequence of partition strings for state variables of a statemachine.
 */
helper statemachines::Statemachine::getStatePartiotions() : Sequence(String) {
	return self.nodes[statemachines::State].map getPartition();
}

/*
 * Returns partiotion string for a state variable.
 */
helper statemachines::State::getPartition() : String {
	return self.name.asSet() + B_UNION + B_TRUE.asSet();
}

/*
 * Returns original string surrounded by curly brackets.
 */
helper String::asSet() : String {
	return B_LBRC + self + B_RBRC;
}

/*
 * Returns original string surrounded by parentheses.
 */
helper String::parenthesize() : String {
	return B_LPAR + self + B_RPAR;
}

/*
 * Returns string representation of a sequence of strings, separated by separator.
 */
helper Sequence(String)::toString(in separator : String) : String {
	var string : String := '';
	var n : Integer := 1;
	var size : Integer := self->size();
	while (n <= size) {
		string := string + self->at(n);
		n := n + 1;
		if n <= size then string := string + separator endif;
	};
	return string;
}