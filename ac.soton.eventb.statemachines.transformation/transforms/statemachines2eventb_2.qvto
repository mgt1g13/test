modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

transformation statemachines2eventb(inout inoutModel:eventb, in inStatemachine:statemachines);

// generator id key
property generatorID : String = "org.eventb.emf.persistence.generator_ID";
// current generator id
property extensionID : String = "ac.soton.eventb.statemachines";

property INIT : String = "INITIALISATION";

property B_EQ : String = " = ";
property B_BEQ : String = " ≔ ";
property B_IN : String = " ∈ ";
property B_BOOL : String = "BOOL";
property B_TRUE : String = "TRUE";
property B_FALSE : String = "FALSE";
property B_NOT : String = " ¬ ";
property B_AND : String = " ∧ ";
property B_OR : String = " ∨ ";
property B_LPAR : String = "(";
property B_RPAR : String = ")";
property B_LBRC : String = "{";
property B_RBRC : String = "}";
property B_COM : String = ", ";
property B_IMPL : String = " ⇒ ";
property B_UNION : String = " ∩ ";


main() {
	inoutModel.rootObjects()[eventb::machine::Machine]->map iumlb2eventb(inStatemachine.rootObjects()![statemachines::AbstractStatemachine]);
}

/*
 * Transforms iumlb to eventb.
 */
mapping inout eventb::machine::Machine::iumlb2eventb(in rootAbstractStatemachine : statemachines::AbstractStatemachine) {
	this.extensionID := rootAbstractStatemachine.getExtensionID();
	self.map machine2nonGeneratedMachine();
	
	variables := rootAbstractStatemachine.map abstractStatemachine2variables()->
		union(variables->asSequence());
	invariants := rootAbstractStatemachine.map abstractStatemachine2typeInvariants()->
		union(rootAbstractStatemachine.map rootAbstractStatemachine2partitionInvariants())->
		union(rootAbstractStatemachine.map abstractStatemachine2substateInvariants())->
		union(rootAbstractStatemachine.map abstractStatemachine2constraintInvariants())->
		union(invariants->asSequence());
	events![name = INIT].actions := rootAbstractStatemachine.map abstractStatemachine2initActions()->
		union(events![name = INIT].actions->asSequence());
	rootAbstractStatemachine.map abstractStatemachine2events();
}

/*
 * Transforms machine to machine free from generated elements.
 */
mapping inout eventb::machine::Machine::machine2nonGeneratedMachine() {
	variables := variables->reject(isGenerated());
	invariants := invariants->reject(isGenerated());
	events.map event2nonGeneratedEvent();
}

/*
 * Transforms event to event free from generated elements.
 */
mapping inout eventb::machine::Event::event2nonGeneratedEvent() {
	guards := guards->reject(isGenerated());
	actions := actions->reject(isGenerated());
}

/*
 * Transforms abstract statemachine to variables.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2variables() : Sequence(eventb::machine::Variable) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2variables();
	}
}

/*
 * Transforms abstract state to variables.
 */
mapping statemachines::AbstractState::abstractState2variables() : Sequence(eventb::machine::Variable) {
	init {
		result := self.map abstractState2variable()->asSequence()->
			union(self.statemachines.map abstractStatemachine2variables()->flatten());
	}
}

/*
 * Transforms abstract state to variable.
 */
mapping statemachines::AbstractState::abstractState2variable() : eventb::machine::Variable {
	name := self.getName();
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract statemachine to type invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2typeInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2typeInvariants();
	}
}

/*
 * Transforms abstract state to type invariants.
 */
mapping statemachines::AbstractState::abstractState2typeInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self[statemachines::State].map state2typeInvariant()->asSequence()->
			union(self.statemachines.map abstractStatemachine2typeInvariants()->flatten());
	}
}

/*
 * Transforms state to type invariant.
 */
mapping statemachines::State::state2typeInvariant() : eventb::machine::Invariant {
	name := self.name + ".type";
	predicate := self.name + B_IN + B_BOOL;
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms root abstract statemachine to partition invariants.
 */
mapping statemachines::AbstractStatemachine::rootAbstractStatemachine2partitionInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self[statemachines::Statemachine].map rootStatemachine2partitionInvariant()->asSequence()->
			union(self.nodes[statemachines::AbstractState].map abstractState2partitionInvariants()->flatten());
	}
}

/*
 * Transforms root statemachine to partition invariant.
 */
mapping statemachines::Statemachine::rootStatemachine2partitionInvariant() : eventb::machine::Invariant
	when { self.nodes[statemachines::State]->size() > 1 }
{
	name := self.name + ".partitionedStates";
	predicate := "partition" + (B_TRUE.asSet() + B_COM + self.getStatePartiotions()->toString(B_COM)).parenthesize();
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract statemachine to partiotion invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2partitionInvariants(in parentState : statemachines::AbstractState) : Sequence(eventb::machine::Invariant) {
	init {
		result := self[statemachines::Statemachine].map statemachine2partitionInvariant(parentState)->asSequence()->
			union(self.nodes[statemachines::AbstractState].map abstractState2partitionInvariants()->flatten());
	}
}

/*
 * Transforms statemachine to partition invariant.
 * Only constructs an invariant if there is more than one state in a statemachine.
 */
mapping statemachines::Statemachine::statemachine2partitionInvariant(in parentState : statemachines::AbstractState) : eventb::machine::Invariant
	when { self.nodes[statemachines::State]->size() > 1 }
{
	name := self.name + ".partitionedStates";
	predicate := (parentState.getName() + B_EQ + B_TRUE).parenthesize() + B_IMPL + "partition" + (B_TRUE.asSet() + B_COM + self.getStatePartiotions()->toString(B_COM)).parenthesize();
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract state to partition invariants.
 */
mapping statemachines::AbstractState::abstractState2partitionInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.statemachines.map abstractStatemachine2partitionInvariants(self);
	}
}

/*
 * Transforms abstract statemachine to substate invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2substateInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2substateInvariants();
	}
}

/*
 * Transforms abstract state to its substates invaraints.
 */
mapping statemachines::AbstractState::abstractState2substateInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.statemachines.nodes[statemachines::AbstractState].map abstractState2substateInvariant(self)->
			union(self.statemachines.map abstractStatemachine2substateInvariants()->flatten());
	}
}

/*
 * Transforms abstract state to substate invariant on parent state.
 */
mapping statemachines::AbstractState::abstractState2substateInvariant(in parentState : statemachines::AbstractState) : eventb::machine::Invariant {
	name := "substates " + self.getName() + B_COM + parentState.getName();
	predicate := (self.getName() + B_EQ + B_TRUE).parenthesize() + B_IMPL + (parentState.getName() + B_EQ + B_TRUE).parenthesize();
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * Transforms abstract statemachine to constraint invariants.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2constraintInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2constraintInvariants();
	}
}

/*
 * Transforms abstract state to constraint invariants.
 */
mapping statemachines::AbstractState::abstractState2constraintInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self[statemachines::State].map state2constraintInvariants()->asSequence()->
			union(self.statemachines.map abstractStatemachine2constraintInvariants()->flatten());
	}
}

/*
 * Transforms state to constraint invariants.
 */
mapping statemachines::State::state2constraintInvariants() : Sequence(eventb::machine::Invariant) {
	init {
		result := self.constraints->collect(c | object eventb::machine::Invariant {
			name := c.name;
			theorem := c.theorem;
			predicate := (self.name + B_EQ + B_TRUE).parenthesize() + B_IMPL + c.predicate.parenthesize();
			generated := true;
			attributes += getGeneratedAttr();
		});
	}
}

/*
 * Transforms abstract statemachine to state variable initialisation actions.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2initActions() : Sequence(eventb::machine::Action) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2initActions();
	}
}

/*
 * Transforms abstract state to state variable initialisation actions.
 */
mapping statemachines::AbstractState::abstractState2initActions() : Sequence(eventb::machine::Action) {
	init {
		result := self[statemachines::State].map state2initAction()->asSequence()->
			union(self.statemachines.map abstractStatemachine2initActions());
	}
}

/*
 * Transforms state to its variable initialisation action.
 * Initialises variable with TRUE if there is an incoming transition
 * that elaborates INITIALISATION event, or with FALSE otherwise.
 */
mapping statemachines::State::state2initAction() : eventb::machine::Action {
	name := self.name + ".init";
	action := self.name + B_BEQ + if self.incoming.elaborates.name->includes(INIT) then B_TRUE else B_FALSE endif;
	generated := true;
	attributes += getGeneratedAttr();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Event & transition transformation (most difficult!!!)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms abstract statemachine to events.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2events() {
	self.transitions.map transition2events();
	self.nodes[statemachines::AbstractState].map abstractState2events();
}

/*
 * Transforms abstract state to events.
 */
mapping statemachines::AbstractState::abstractState2events() {
	self.statemachines.map abstractStatemachine2events();
}

/*
 * Transforms transition to events that it elaborates.
 */
mapping statemachines::Transition::transition2events() {
	self.elaborates[name <> INIT].map extendEvent(self);
}

/*
 * Extends existing event with generated stuff from transition, which elaborates this event.
 */
mapping inout eventb::machine::Event::extendEvent(in transition : statemachines::Transition) {
	self.guards := transition.source.externalise().map abstractState2eventGuard(transition)->union(self.guards);
	self.actions := transition.source.externalise().map sourceAbstractState2leaveActions(transition)->
		union(transition.target.externalise().map targetAbstractState2enterActions(transition))->
		union(self.actions->asSequence());
}

/*
 * Transforms abstract state to event guard.
 * Parameter is not used, but is compulsory as mapping can be called many times on the same input state, but for different transitions!
 */
mapping statemachines::AbstractState::abstractState2eventGuard(in transition : statemachines::Transition) : eventb::machine::Guard {
	name := "isin_" + self.getName();
	predicate := self.getName() + B_EQ + B_TRUE;
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * ----------------------------------------------------------------------------------------------------------------------------------------------------------
 * Algorithm for leaving states:
 *
 * prior step (applicable only for domain model with ANY state): externalise local transition's source and target i.e. if it's ANY state, make it superstate
 *
 * 1) find common superstate of source and target, including source itself in the result (in case of local transition)
 * 2) leave all superstates of source up to result, found in 1), but not including it
 * 3) leave all substates of source
 *
 * extended steps, to support parallel statemachines if exist:
 * 2') also leave their (superstates') parallel statemachines, which don't include source
 * 3') if transition is local, ignore parallel statemachines of source, which do not contain target (to avoid leaving and entering in parallel statemachines)
 * ----------------------------------------------------------------------------------------------------------------------------------------------------------
 */

/*
 * Transforms source abstract state of transition to leave actions.
 * Produces leave actions for all superstates of source state (including source itself) that are not common with superstates of target state
 * and leave actions for all substates of source state, not including parallel statemachines if transition is local.
 */
mapping statemachines::AbstractState::sourceAbstractState2leaveActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.getSuperstates()->reject(s | transition.target.externalise().getSuperstates()->includes(s)).map superstate2leaveActions(transition)->
			union(self.statemachines->reject(transition.isLocal() and not contains(transition.target)).map abstractStatemachine2leaveActions(transition));
	}
}

/*
 * Transforms superstate to leave actions.
 * Produced leave action for superstate and leave actions for all parallel statemachines of superstate, which do not contain source state.
 */
mapping statemachines::AbstractState::superstate2leaveActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.map abstractState2leaveAction(transition)->asSequence()->
			union(self.statemachines[not contains(transition.source)].map abstractStatemachine2leaveActions(transition)->flatten());
	}
}

/*
 * Transforms abstract statemachine to leave actions.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2leaveActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2leaveActions(transition);
	}
}

/*
 * Transforms abstract state to leave actions.
 */
mapping statemachines::AbstractState::abstractState2leaveActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.map abstractState2leaveAction(transition)->asSequence()->
			union(self.statemachines.map abstractStatemachine2leaveActions(transition)->flatten());
	}
}

/*
 * Transforms abstract state to leave action.
 * Ignores state if it is target state of transition.
 */
mapping statemachines::AbstractState::abstractState2leaveAction(in transition : statemachines::Transition) : eventb::machine::Action
	when { self <> transition.target }
{
	name := "leave_" + self.getName();
	action := self.getName() + B_BEQ + B_FALSE;
	generated := true;
	attributes += getGeneratedAttr();
}

/*
 * ----------------------------------------------------------------------------------------------------------------------------------------------------------
 * Algorithm for entering states:
 *
 * prior step (applicable only for domain model with ANY state): externalise local transition's source and target i.e. if it's ANY state, make it superstate
 *
 * 1) find common superstate of target and source, including target itself in the result (in case of local transition)
 * 2) enter all superstates of target up to result, found in 1), but not including it
 * 3) enter all substates of target, if there are any initial states (by initial state understand not Initial-typed state, but state, connected with Initial)
 *
 * extended steps, to support parallel statemachines if exist:
 * 2') also enter their (superstates') parallel statemachines, which don't include target
 * 3') if transition is local, ignore parallel statemachines of target, which do not contain source (to avoid leaving and entering in parallel statemachines)
 * ----------------------------------------------------------------------------------------------------------------------------------------------------------
 */

/*
 * Transforms target abstract state to enter actions.
 * Produces enter actions for all superstates of target state (including target state itself) that are not common with superstates of source state
 * and enter actions for substates of target state, not including parallel statemachines if transition is local.
 */
mapping statemachines::AbstractState::targetAbstractState2enterActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.getSuperstates()->reject(s | transition.source.externalise().getSuperstates()->includes(s)).map superstate2enterActions(transition)->asSequence()->
			union(self.statemachines->reject(transition.isLocal() and not contains(transition.source)).map abstractStatemachine2enterActions(transition));
	}
}

/*
 * Transforms superstate to enter actions.
 * Produces enter action for superstate and enter actions for all parallel statemachines of superstate, which do not contain target.
 */
mapping statemachines::AbstractState::superstate2enterActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.map abstractState2enterAction(transition)->asSequence()->
			union(self.statemachines[not contains(transition.target)].map abstractStatemachine2enterActions(transition));
	}
}

/*
 * Transforms abstract statemachine to enter actions.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2enterActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.getInitialState().map abstractState2enterActions(transition);
	}
}

/*
 * Transforms abstract state to enter actions.
 */
mapping statemachines::AbstractState::abstractState2enterActions(in transition : statemachines::Transition) : Sequence(eventb::machine::Action) {
	init {
		result := self.map abstractState2enterAction(transition)->asSequence()->
			union(self.statemachines.map abstractStatemachine2enterActions(transition));
	}
}

/*
 * Transforms abstract state to enter action.
 */
mapping statemachines::AbstractState::abstractState2enterAction(in transition : statemachines::Transition) : eventb::machine::Action {
	name := "enter_" + self.getName();
	action := self.getName() + B_BEQ + B_TRUE;
	generated := true;
	attributes += getGeneratedAttr();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// query and helper rules
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Returns if eventB element is generated or not.
 */
query eventb::EventBElement::isGenerated() : Boolean {
	return self.generated = true
		and self.attributes->exists(key = generatorID)
		and self.attributes![key = generatorID].value.value = extensionID;
}

/*
 * Returns 'generated' attribute.
 */
helper getGeneratedAttr() : StringToAttributeMapEntry {
	return object StringToAttributeMapEntry {
		key := generatorID;
		value := object Attribute {
			type := AttributeType::String;
			value := extensionID;
		}
	}
}

/*
 * Returns the name of an abstract state.
 */
helper statemachines::AbstractState::getName() : String {
	return if (self.oclIsTypeOf(statemachines::State)) 
	then self.oclAsType(statemachines::State).name 
	else self.oclAsType(statemachines::RefinedState).label endif;
}

/*
 * Returns a sequence of partition strings for state variables of a statemachine.
 */
helper statemachines::Statemachine::getStatePartiotions() : Sequence(String) {
	return self.nodes[statemachines::State].map getPartition();
}

/*
 * Returns partiotion string for a state variable.
 */
helper statemachines::State::getPartition() : String {
	return self.name.asSet() + B_UNION + B_TRUE.asSet();
}

/*
 * Returns original string surrounded by curly brackets.
 */
helper String::asSet() : String {
	return B_LBRC + self + B_RBRC;
}

/*
 * Returns original string surrounded by parentheses.
 */
helper String::parenthesize() : String {
	return B_LPAR + self + B_RPAR;
}

/*
 * Returns string representation of a sequence of strings, separated by separator.
 */
helper Sequence(String)::toString(in separator : String) : String {
	var string : String := '';
	var n : Integer := 1;
	var size : Integer := self->size();
	while (n <= size) {
		string := string + self->at(n);
		n := n + 1;
		if n <= size then string := string + separator endif;
	};
	return string;
}

/*
 * Externalises abstract node to abstract state.
 * Returns 
 * - itself, if already an abstract state
 * - superstate, which is abstract state, if ANY state
 * - otherwise null.
 * This helper is required for local transitions (that use ANY state as source/target) to convert them to external for subsequent transformation.
 */
helper statemachines::AbstractNode::externalise() : statemachines::AbstractState {
	return if self.oclIsTypeOf(statemachines::ANY)
		then if self.eContainer().eContainer().oclIsKindOf(statemachines::AbstractState)
			then self.eContainer().eContainer().oclAsType(statemachines::AbstractState)
			endif
		else if self.oclIsKindOf(statemachines::AbstractState)
			then self.oclAsType(statemachines::AbstractState)
			else null
			endif
		endif;
}

/*
 * Returns all abstract states that are superstates of input state.
 * Result includes input state itself.
 */
helper statemachines::AbstractState::getSuperstates() : Sequence(statemachines::AbstractState) {
	return if self.eContainer().eContainer().oclIsKindOf(statemachines::AbstractState)
		then self.eContainer().eContainer().oclAsType(statemachines::AbstractState).getSuperstates()->union(self->asSequence())
		else self->asSequence()
		endif;
}

/*
 * Returns true if transition is local i.e.
 * source state is ANY and target state is a substate of source's statemachine or
 * target state is ANY and source state is a substate of target's statemachine.
 */
query statemachines::Transition::isLocal() : Boolean {
	return (self.source.oclIsTypeOf(statemachines::ANY) and self.source.eContainer().oclAsType(statemachines::AbstractStatemachine).contains(self.target)) or
		(self.target.oclIsTypeOf(statemachines::ANY) and self.target.eContainer().oclAsType(statemachines::AbstractStatemachine).contains(self.source));
}

/*
 * Returns true if abstract satemachine contains a node amongst its states or substates.
 */
query statemachines::AbstractStatemachine::contains(in node : statemachines::AbstractNode) : Boolean {
	return self.nodes->includes(node) or self.nodes[statemachines::AbstractState].statemachines->exists(contains(node));
}

/*
 * Returns first initial state found in statemachine i.e. abstract state that is linked by incoming transition from 'Initial' state.
 */
helper statemachines::AbstractStatemachine::getInitialState() : statemachines::AbstractState {
	return if not self.nodes[statemachines::Initial]->isEmpty()
		then self.nodes![statemachines::Initial].outgoing->first().target.oclAsType(statemachines::AbstractState)
		else null
		endif;
}

/*
 * Returns extension id of abstract statemachine if it's an abstract extension.
 */
helper statemachines::AbstractStatemachine::getExtensionID() : String {
	return if self.oclIsKindOf(eventb::AbstractExtension)
		then self.oclAsType(eventb::AbstractExtension).extensionId
		else null
		endif;
}