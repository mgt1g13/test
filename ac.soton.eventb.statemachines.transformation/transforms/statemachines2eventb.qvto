modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

transformation statemachines2eventb(inout inoutModel:eventb);

// generator id key
property generatorID : String = "org.eventb.emf.persistence.generator_ID";
// current generator id
property id : String = "ac.soton.eventb.statemachines";

// transformed machine
property machine : eventb::machine::Machine = null;
property initevent : eventb::machine::Event = null;

property INIT : String = "INITIALISATION";

property B_EQ : String = " = ";
property B_BEQ : String = " ≔ ";
property B_IN : String = " ∈ ";
property B_BOOL : String = "BOOL";
property B_TRUE : String = "TRUE";
property B_FALSE : String = "FALSE";
property B_NOT : String = " ¬ ";
property B_AND : String = " ∧ ";
property B_OR : String = " ∨ ";
property B_LPAR : String = "(";
property B_RPAR : String = ")";
property B_IMPL : String = " ⇒ ";

helper eventb::EventBElement::generatedAttr() : StringToAttributeMapEntry {
	return object StringToAttributeMapEntry {
		key := generatorID;
		value := object Attribute {
			type := AttributeType::String;
			value := id;
		}
	}
}

query eventb::EventBElement::isGenerated() : Boolean {
	return self.generated = true and self.attributes![key = generatorID].value.value = id;
}

query statemachines::AbstractState::getName() : String {
	return if (self.oclIsTypeOf(statemachines::State)) 
	then self.oclAsType(statemachines::State).name 
	else self.oclAsType(statemachines::RefinedState).label endif;
}

main() {
	inoutModel.rootObjects()[eventb::machine::Machine]->map umlb2eventb();
}

// machine -> event-b
mapping inout eventb::machine::Machine::umlb2eventb() {
	init {
		machine := self;
		initevent := machine.events![name = INIT];
	}
	map removeGenerated();
	extensions![statemachines::AbstractStatemachine].map statemachine2eventb();
}
// remove generated stuff in machine
mapping inout eventb::machine::Machine::removeGenerated() {
	variables := variables->reject(isGenerated());
	invariants := invariants->reject(isGenerated());
	events.map removeGenerated();
}

// remove generated stuff in event
mapping inout eventb::machine::Event::removeGenerated() {
	guards := guards->reject(g | g.generated = true);
	actions := actions->reject(a | a.generated = true);
}

// abstract statemachine -> states, refined states and transitions
mapping inout statemachines::AbstractStatemachine::statemachine2eventb() {
	nodes[statemachines::State].map state2eventb();
	nodes[statemachines::RefinedState].map state2eventb();
	nodes[statemachines::State].map disjoin();
	transitions.map transition2eventb();
}

// state -> variable, type invariant and init action
mapping inout statemachines::State::state2eventb() {
	init {
		// initial value of variable depending on elaborated events
		var initvalue : String;
		if (self.incoming.elaborates[name = INIT]->isEmpty()) then {
			initvalue := B_FALSE;
		} else {
			initvalue := B_TRUE;
		} endif;
	}
	// variable
	machine.variables := machine.variables->prepend(object eventb::machine::Variable {
		name := self.name;
		generated := true;
		attributes += generatedAttr();
	});
	// type invariant
	machine.invariants := machine.invariants->prepend(object eventb::machine::Invariant {
		name := self.name + ".type";
		predicate := self.name + B_IN + B_BOOL;
		generated := true;
		attributes += generatedAttr();
	});
	// INITIALISATION action
	initevent.actions := initevent.actions->prepend(object eventb::machine::Action {
		name := self.name + ".init";
		action := self.name + B_BEQ + B_FALSE;
		generated := true;
		attributes += generatedAttr();
	});
	self.constraints.map constraint2eventb(self.name);
	self.statemachines.map statemachine2eventb();
}

// refined state -> variable and init action
mapping inout statemachines::RefinedState::state2eventb() {
	init {
		// initial value of variable depending on elaborated events
		var initvalue : String;
		if (self.incoming.elaborates[name = INIT]->isEmpty()) then {
			initvalue := B_FALSE;
		} else {
			initvalue := B_TRUE;
		} endif;
	}
	// variable
	machine.variables := machine.variables->prepend(object eventb::machine::Variable {
		name := self.label;
		generated := true;
		attributes += generatedAttr();
	});
	// INITIALISATION action
	initevent.actions := initevent.actions->prepend(object eventb::machine::Action {
		name := self.label + ".init";
		action := self.label + B_BEQ + initvalue;
		generated := true;
		attributes += generatedAttr();
	});
	self.constraints.map constraint2eventb(self.label);
	self.statemachines.map statemachine2eventb();
}

// invariant -> eventb machine invariant
mapping inout eventb::machine::Invariant::constraint2eventb(in varName : String) {
	machine.invariants := machine.invariants->prepend(object eventb::machine::Invariant {
		name := self.name;
		predicate := B_LPAR + varName + B_EQ + B_TRUE + B_RPAR + B_IMPL + B_LPAR + self.predicate + B_RPAR;
		generated := true;
	});
}

// add disjoint invariant
mapping inout statemachines::State::disjoin() {
	self.eContainer().oclAsType(statemachines::AbstractStatemachine).nodes[statemachines::State]->forEach(s | s <> self) {
		// don't duplicate (ckeck if no invariant created already for these states)
		if (machine.invariants->name[endsWith(s.name + "," + self.name)]->isEmpty()) then {
			machine.invariants += object eventb::machine::Invariant {
				name := "disjointStates " + self.name + "," + s.name;
				predicate := B_NOT + B_LPAR + self.name + B_EQ + B_TRUE + B_AND + s.name + B_EQ + B_TRUE + B_RPAR;
				generated := true;
			};
		} endif;
	};
}

// transition -> eventb elaborated events
mapping inout statemachines::Transition::transition2eventb() {
	elaborates.map transition2elaborates(self);
}

// elaborated event + transition -> event guard and actions
mapping inout eventb::machine::Event::transition2elaborates(in transition : statemachines::Transition) {
	init {
		// objects
		var source : statemachines::AbstractState := transition.source![statemachines::AbstractState];
		var target : statemachines::AbstractState := transition.target![statemachines::AbstractState];
	}
	// source state guard and leave action
	if (source <> null) then {
		guards := guards->prepend(object eventb::machine::Guard {
			name := "isin_" + source.getName();
			predicate := source.getName() + B_EQ + B_TRUE;
			generated := true;
			attributes += generatedAttr();
		});
			
		actions := actions->prepend(object eventb::machine::Action {
			name := "leaveState_" + source.getName();
			action := source.getName() + B_BEQ + B_FALSE;
			generated := true;
		});
	} endif;
	// target state enter action
	if (target <> null) then {
		actions := actions->prepend(object eventb::machine::Action {
			name := "enterState_" + target.getName();
			action := target.getName() + B_BEQ + B_TRUE;
			generated := true;
		});
	} endif;
}