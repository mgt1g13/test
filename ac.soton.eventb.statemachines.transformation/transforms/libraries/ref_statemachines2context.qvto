import util;
	
	
modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines/1013');
	
library set_statemachines2context;
property RootStatemachine : Statemachine = null;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constants
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to constants.
 */
mapping statemachines::Statemachine::statemachine2constants(in generatorID : String) : Sequence(eventb::context::Constant) {
	init {
		RootStatemachine := self;
		result := self.nodes[statemachines::State].map state2constants(generatorID);
	}
}

/*
 * Transforms state to constants.
 */
mapping statemachines::State::state2constants(in generatorID : String) : Sequence(eventb::context::Constant) {
	init {
		result := self.map state2constant(generatorID)->asSequence()->
			union(self.statemachines.nodes[statemachines::State].map state2constants(generatorID)->flatten());
	}
}

/*
 * Transforms statemachine to constant.
 */
mapping statemachines::Statemachine::statemachine2constant(in generatorID : String) : eventb::context::Constant 
	when { self._refines = null }
{
	name := self.name + _NULL;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms state to constant.
 */
mapping statemachines::State::state2constant(in generatorID : String) : eventb::context::Constant 
	when { self._refines = null }
{
	name := self.name;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sets
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to sets.
 */
mapping statemachines::Statemachine::statemachine2sets(in generatorID : String) : Sequence(eventb::context::CarrierSet) {
	init {
		result := self.map statemachine2set(generatorID)->asSequence()->
			union(self.nodes[statemachines::State].statemachines.map statemachine2sets(generatorID)->flatten());
	}
}

/*
 * Transforms statemachine to set.
 */
mapping statemachines::Statemachine::statemachine2set(in generatorID : String) : eventb::context::CarrierSet 
	when { self._refines = null and not self.hasParentState() }
{
	name := self.name + _STATES;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Type axioms
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to type axioms.
 */
mapping statemachines::Statemachine::statemachine2typeAxioms(in generatorID : String) : Sequence(eventb::context::Axiom) {
	init {
		result := self.nodes[statemachines::State].map state2typeAxioms(generatorID);
	}
}

/*
 * Transforms state to type axioms.
 */
mapping statemachines::State::state2typeAxioms(in generatorID : String) : Sequence(eventb::context::Axiom) {
	init {
		result := self.map state2typeAxiom(generatorID)->asSequence()->
			union(self.statemachines.nodes[statemachines::State].map state2typeAxioms(generatorID)->flatten());
	}
}

/*
 * Transforms state to type axiom.
 */
mapping statemachines::State::state2typeAxiom(in generatorID : String) : eventb::context::Axiom 
	when { self._refines = null }
{
	name := TYPEOF_ + self.name;
	predicate := self.name + "\u2286" + RootStatemachine.name + _STATES;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms statemachine to non empty axioms.
 */
mapping statemachines::Statemachine::statemachine2nonEmptyAxioms(in generatorID : String) : Sequence(eventb::context::Axiom) {
	init {
		result := self.nodes[statemachines::State].map state2nonEmptyAxioms(generatorID);
	}
}
/*
 * Transforms state to non empty axioms.
 */
mapping statemachines::State::state2nonEmptyAxioms(in generatorID : String) : Sequence(eventb::context::Axiom) {
	init {
		result := self.map state2nonEmptyAxiom(generatorID)->asSequence()->
			union(self.statemachines.nodes[statemachines::State].map state2nonEmptyAxioms(generatorID)->flatten());
	}
}

/*
 * Transforms state to non empty axiom.
 */
mapping statemachines::State::state2nonEmptyAxiom(in generatorID : String) : eventb::context::Axiom 
	when { self._refines = null }
{
	name := "Non_Empty_" + self.name;
	predicate := self.name + B_NEQ + "\u2205";
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Transforms statemachine to type axiom.
 */
mapping statemachines::Statemachine::statemachine2typeAxiom(in generatorID : String) : eventb::context::Axiom 
	when { self._refines = null and not self.hasParentState()}
{
	name := TYPEOF_ + self.name;
	predicate := self.name + _NULL + B_IN + self.name + _STATES;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Partition axioms
//
// Example: @distinct_states_in_idle_sm_STATES partition(idle_sm_STATES,{available},{notAvaliable},{idle_sm_NULL})
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to partition axioms.
 */
mapping statemachines::Statemachine::statemachine2partitionAxioms(in generatorID : String) : Sequence(eventb::context::Axiom) {
	init {
		result := self.map statemachine2partitionAxiom(generatorID)->asSequence()->
			union(self.nodes[statemachines::State].statemachines.map statemachine2partitionAxioms(generatorID)->flatten());
	}
}

/*
 * Transforms statemachine to partition axiom.
 */
mapping statemachines::Statemachine::statemachine2partitionAxiom(in generatorID : String) : eventb::context::Axiom 
	when { self._refines = null }
{
	if(not self.hasParentState()) then{
	name := DISTINCT_STATES_IN_ + self.name + _STATES;
	predicate := "partition" + (self.name + _STATES + B_COM + self.getStateNames()->toString(B_COM)).parenthesize();
	generated := true;
	attributes += getGeneratedAttr(generatorID);
	}
	else{
	name := DISTINCT_STATES_IN_ + self.getSuperState().name;
	predicate := "partition" + (self.getSuperState().name + B_COM + self.getStateNames()->toString(B_COM)).parenthesize();
	generated := true;
	attributes += getGeneratedAttr(generatorID);	
	}
	endif
}