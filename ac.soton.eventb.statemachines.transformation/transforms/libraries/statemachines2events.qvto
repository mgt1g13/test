import util;
//import libraries.statemachines2events_enter;
import libraries.vars_statemachines2events_leave;
import libraries.enum_statemachines2events_leave;

modeltype eventb uses core('http://emf.eventb.org/models/core/2014');
modeltype coreextension uses coreextension('http://soton.ac.uk/models/eventb/coreextension/2014');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines/2014');

library statemachines2events;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////// Generate Guards and Actions into Elaborated Events  ////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Works for both translation kinds

/*
 * Transforms root statemachine to events.
 * Augments events with guards and actions.
 * First generates guards and enter actions, then leave actions (to be able to track enter actions and avoid multiple action generation on same variable).
 */
mapping statemachines::Statemachine::rootStatemachine2events(in generatorID : String) {
	self.map statemachine2events(generatorID);
	self.map statemachine2eventsLeave(generatorID);
}

/*
 * Transforms statemachine to events.
 * Augments events with guards and enter actions generated from transitions.
 */
mapping statemachines::Statemachine::statemachine2events(in generatorID : String) {
	self.transitions.map transition2events(generatorID);
	self.nodes[statemachines::State].statemachines.map statemachine2events(generatorID);
}

/*
 * Transforms transition to event with guards and enter actions.
 * Generates guards and enter actions for events elaborated by transition.
 * Skips initialisation event.
 */
mapping statemachines::Transition::transition2events(in generatorID : String) {
	self.elaborates[name <> INIT].map event2statemachinesEvent(self, generatorID);
}

/*
 * Transforms event to same event augmented with guard and enter actions.
 * Generates guard and enter actions from transition and adds to event.
 * Skips mapping of enter actions for self-loop transitions.
 */
mapping inout eventb::machine::Event::event2statemachinesEvent(in transition : statemachines::Transition, in generatorID : String) {

	self.parameters := 
		transition.target.getRootStatemachine()[transition.target.getRootStatemachine().instances!=null].map rootStatemachine2parameter(self, generatorID)->
		union(transition.parameters.map transitionParameter2parameter(self, generatorID)->asOrderedSet())->
		union(self.parameters);

	self.witnesses := 
		transition.witnesses.map transitionWitness2witness(self, generatorID)->asOrderedSet()->
		union(self.witnesses);

	self.guards := 
		transition.map transition2sourceGuards(self, generatorID) ->
		union(transition.map initialTransition2sourceGuard(self, generatorID)->asOrderedSet()) -> reject(""=name) ->
		union(transition.parameters.map transitionParameter2guard(self, generatorID)->asOrderedSet())->
		union(transition.guards.map transitionGuard2guard(self, generatorID)->asOrderedSet())->
		union(self.guards);

	self.actions := 
		transition.map transition2enterActions(self, generatorID) -> reject(""=name) ->
		union(transition.actions.map transitionAction2action(self, generatorID)->asOrderedSet())->
		union(self.actions);
}

/*
 * Generates source guards for the transition as the collection,
 * if source is of type STATE, that state is occupied,
 * else, if source is of type Fork, take the union of the actions generated by recursively calling this rule for each incoming transition to the fork
 * else, if source is of type Junction, generate one guard for the junction using rule junction2sourceGuard
 */

mapping statemachines::Transition::transition2sourceGuards(inout event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Guard) {
	init {
		result := self[source<>target].source[statemachines::State].map sourceState2sourceGuard(event, generatorID) ->
					union(self[source<>target].source[statemachines::Fork].incoming.map transition2sourceGuards(event, generatorID)->asOrderedSet()) ->
					union(self[source<>target and source.oclIsKindOf(statemachines::Junction)].map junction2disjunctiveSourceGuard(event, generatorID)->asOrderedSet());
	}
}

/*
 * Generates a single disjunctive guard representing the condition for an outgoing transition from a junction to be enabled.
 * Any upstream junctions or forks are considered in the forming of the predicate.
 */

mapping statemachines::Transition::junction2disjunctiveSourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
	when{self.source.oclIsKindOf(statemachines::Junction)} {
		init{
			var nm : String = "";
			var pred : String = "";
			self.source.incoming[source<>target and source.oclIsKindOf(statemachines::State)].map guardedTransition2conjunctiveSourceGuard(event, generatorID)->asBag() ->
			union(self.source.incoming[source<>target and source.oclIsKindOf(statemachines::Junction)].map junction2disjunctiveSourceGuard(event, generatorID)->asBag()) ->
			union(self.source.incoming[source<>target and source.oclIsKindOf(statemachines::Fork)].map fork2conjunctiveSourceGuard(event, generatorID)->asBag()) ->
			forEach(gs){
				if (gs.name!=null) then {
					if (nm="") then {nm := gs.name} else {nm := nm + "_or_" + gs.name} endif;
					if (pred="") then {pred := gs.predicate} else {pred := pred + B_OR + gs.predicate} endif;
				} endif;
		};
		//if nm="" then return null endif; doesn't work - reject later
		}
		name := nm;
		predicate := self.addTransitionGuards("("+pred+")");	
		generated := true;
		attributes += getGeneratedAttr(generatorID);	
}

/*
 * Generates a single conjunctive guard representing the condition for a Join (fork) to be enabled.
 * N.B. this should only be used when the outgoing leads to a downstream junction which means that the conjunctive guard will be used as a clause in a disjunction.
 * When a downstream junction is not involved the fork should be handled by generating multiple seperate guards.
 */

mapping statemachines::Transition::fork2conjunctiveSourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
	when{self.source.oclIsKindOf(statemachines::Fork)} {
		var nm : String = "";
		var pred : String = "";
		self.source.incoming[source<>target and source.oclIsKindOf(statemachines::State)].map guardedTransition2conjunctiveSourceGuard(event, generatorID) -> forEach(gs){
			if (nm="") then {nm := gs.name} else {nm := nm + "_and_" + gs.name} endif;
			if (pred="") then {pred := gs.predicate} else {pred := pred + B_AND + gs.predicate} endif;
		};
		name := nm;
		//predicate := "("+self.addTransitionGuards(pred)+")";	
		predicate := self.addTransitionGuards(pred);
		generated := true;
		attributes += getGeneratedAttr(generatorID);	
}

/*
 * Generates enter state actions for the transition as the collection
 * if target is of type STATE, enter that state,
 * else, if target is of type FORK, take the union of the actions generated by recursively calling this rule for each outgoing transition from the fork
 */

mapping statemachines::Transition::transition2enterActions(inout event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self[source<>target].target[statemachines::State].map targetState2enterActions(event, self, generatorID) ->
					union(self[source<>target].target[statemachines::Fork].outgoing.map transition2enterActions(event, generatorID)->asOrderedSet());
	}
}

//
// Parameters
//

mapping coreextension::TypedParameter::transitionParameter2parameter(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Parameter
 {
 	name := self.name;
 	comment := self.comment;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }
 
mapping statemachines::Statemachine::rootStatemachine2parameter(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Parameter
 when{ self.isRootStatemachine() and not(event.containsParameterWithName(self.selfName)) }
 {
 	name := self.selfName;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }
 
 //
 // Witnesses
 //
 
 mapping eventb::machine::Witness::transitionWitness2witness(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Witness
 {
 	name := self.name;
 	predicate := self.predicate;
 	comment := self.comment;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }
 
 //
 // Guards
 //
 
 mapping coreextension::TypedParameter::transitionParameter2guard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 {
 	name := self.name+"_type";
 	predicate := self.name+B_IN+self.type;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }
 
  mapping eventb::machine::Guard::transitionGuard2guard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 {
 	name := self.name;
 	predicate := self.predicate;
 	theorem := self.theorem;
 	comment := self.comment;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }
 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Source guard
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms guarded transition from source state to a conjunctive source guard representing the transition source and transition guards.
 * Skips transformation if event contains source guard on the same state already.
 * NOTE - THIS RULE SHOULD ONLY BE USED TO GENERATE A SUB-CLAUSE IN A DISJUNCTION (E.G. WHEN THERE IS A DOWNSTREAM JUNCTION).
 *  NORMALLY TRANSITION GUARDS ARE JUST ADDED TO THE EVENT'S GUARD COLLECTION
 */

 mapping statemachines::Transition::guardedTransition2conjunctiveSourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 when{self.source.oclIsTypeOf(statemachines::State) and 
 		not( 
 			event.containsGuardWithPrefix(ISIN_ + self.source.oclAsType(statemachines::State).name) 
 			or 
 			event.containsGuardWithSuffix(ISIN_ + self.source.oclAsType(statemachines::State).name)) }
 {
		name := ISIN_ + self.source.oclAsType(statemachines::State).name;
		predicate := self.addTransitionGuards(self.source.oclAsType(statemachines::State).getSourceStatePredicate());
		generated := true;
		attributes += getGeneratedAttr(generatorID);
}

/*
 * Adds to the given predicate, by conjunction, the predicates from the guards of the
 * contextual transition segment, which does not target a real state.
 * NOTE - THIS RULE SHOULD ONLY BE USED TO GENERATE A SUB-CLAUSE IN A DISJUNCTION (E.G. WHEN THERE IS A DOWNSTREAM JUNCTION).
 *  NORMALLY TRANSITION GUARDS ARE JUST ADDED TO THE EVENT'S GUARD COLLECTION
 */
helper statemachines::Transition::addTransitionGuards(in predicate : String) : String {
	var p : String = predicate;
	if not self.target.oclIsKindOf(statemachines::State) and not self.guards->isEmpty() then {
		self.guards->forEach(g){
			p := p+B_AND+g.predicate;
		};
		p := "("+p+")"; }
	endif;
	return p;
}

/*
 * Transforms source state to source guard.
 * Generates guard for source state and particular event.
 * Skips transformation if event contains source guard on the same state already.
 */

mapping statemachines::State::sourceState2sourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 when{ not( event.containsGuardWithPrefix(ISIN_ + self.name) or event.containsGuardWithSuffix(ISIN_ + self.name)) }
 {
	name := ISIN_ + self.name;
	predicate := self.getSourceStatePredicate();
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

/*
 * Returns a predicate string representing the guard for the transition source state
 * for enumeration translation this is either statemachine = state or statemachine(self) = state depending on lifting
 * for variables translation this is either state = TRUE of self : state depending on lifting
 */
helper statemachines::State::getSourceStatePredicate() : String {
var root : statemachines::Statemachine := self.getRootStatemachine();
	return
		switch{
		case (root.translation = statemachines::TranslationKind::SINGLEVAR)
			if root.instances = null then
				self.getStatemachine().name + B_EQ + self.name
			else 
				self.getStatemachine().name+(root.selfName).parenthesize()+B_EQ+self.name
			endif;	
		case (root.translation = statemachines::TranslationKind::MULTIVAR)	
			if root.instances = null then
				self.name + B_EQ + B_TRUE
			else 
				root.selfName+B_IN+self.name
			endif;
		else
			"<Statemachine translation error: unknown translation kind>";
		};
}

/*
 * Only for transitions from the root initial state when the root statemachine has a final state
 * Transforms initial transition to guard that the statemachine is not active.
 * Generates guard for source state and particular event.
 * Skips transformation if event contains source guard on the same state already.
 */

mapping statemachines::Transition::initialTransition2sourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 when{ self.source.oclIsKindOf(statemachines::Initial) and
 		self.source.getStatemachine().isRootStatemachine() and
 		self.source.getStatemachine().hasFinalState() and
 		not(event.containsGuardWithPrefix(ISNOTIN_ + self.source.getStatemachine().name) or
 			 event.containsGuardWithSuffix(ISNOTIN_ + self.source.getStatemachine().name)) }
 {
		name := ISNOTIN_ + self.source.getStatemachine().name;
		predicate := self.getStateMachineNotActivePredicate();
		generated := true;
		attributes += getGeneratedAttr(generatorID);
 }

/*
 * Returns a predicate string representing the guard that the root statemachine being activiated is not already activiated
 * for enumeration translation this is either statemachine = null or statemachine(self) = null depending on lifting
 * for variables translation this is either TRUE or self /: union of states depending on lifting
 */
helper statemachines::Transition::getStateMachineNotActivePredicate() : String {
var root : statemachines::Statemachine := self.source.getRootStatemachine();
	return
		switch{
		case (root.translation = statemachines::TranslationKind::SINGLEVAR)
			if root.instances = null then
				self.source.getStatemachine().name + B_EQ + self.source.getStatemachine().name+_NULL
			else 
				self.source.getStatemachine().name+(root.selfName).parenthesize()+B_EQ+self.source.getStatemachine().name+_NULL
			endif;
		case (root.translation = statemachines::TranslationKind::MULTIVAR)				
			if root.instances = null then
				B_TRUE+B_NOTIN+(self.source.getStatemachine().getStateNamesAsSingletons()->toString(B_UNION)).parenthesize()
			else 
				root.selfName+B_NOTIN+(self.source.getStatemachine().getStateNames()->toString(B_UNION)).parenthesize()
			endif;
		else
			"<Statemachine translation error: unknown translation kind>";
		};
}

 
 //
 // Actions
 //
 
  mapping eventb::machine::Action::transitionAction2action(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action
 {
 	name := self.name;
 	action := self.action;
 	comment := self.comment;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////// Generate Actions for entering the new target state and any superstates as necessary ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms target state to enter actions.
 * Generates enter actions for all the superstates of target state, 
 * which are not common to source state's superstates,
 * as well as enter actions for target state's statemachines,
 * excluding parallel statemachines that don't contain source state 
 * if transition is local and is directed from nested state towards its parent state.
 */
mapping statemachines::State::targetState2enterActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := (self.getSuperstates()-(transition.source.getSuperstates()))[statemachines::State].map state2enterAction(event, generatorID);
	}
}

/*
 * Transforms state to enter action.
 * Generates enter action for targeted state and particular event.
 * Skips transformation if event contains enter action on the same state already.
 */
mapping statemachines::State::state2enterAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action 
	when { not event.containsAction(ENTER_ + self.name) }
{
	var root : statemachines::Statemachine := self.getRootStatemachine();
	name := ENTER_ + self.name;
	switch{
	case (root.translation = statemachines::TranslationKind::MULTIVAR)
		action :=
			if root.instances = null then
				self.name+B_BEQ+B_TRUE
			else
				self.name+B_BEQ+self.name+B_UNION+self.getRootStatemachine().selfName.asSet()
			endif;
	case (root.translation = statemachines::TranslationKind::SINGLEVAR)
		action :=
			if root.instances = null then
				self.getStatemachine().name + B_BEQ + self.name
			else
				self.getStatemachine().name+(root.selfName).parenthesize()+B_BEQ+self.name
			endif;
	else
		action := "<Statemachine translation error: unknown translation kind>";
	};
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////// Generate Actions for leaving the old source state and any superstates as necessary ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////
// WAS IN statemachines2events_leave ///
////////////////////////////////////////
/*
 * Transforms statemachine hierarchy by adding transition leave actions to all elaborated events.
 * Separated from event transformation rules (which generate guards and enter actions) 
 * to be able to track enter actions already generated
 * and avoid generation of leave action if enter action on the same statemachine exists.
 */
mapping statemachines::Statemachine::statemachine2eventsLeave(in generatorID : String) {
	self.transitions.map transition2eventsLeave(generatorID);
	self.nodes[statemachines::State].statemachines.map statemachine2eventsLeave(generatorID);
}

/*
 * Transforms transition to source state leave actions in all events elaborated by the transition
 * except the initialisation event.
 */
mapping statemachines::Transition::transition2eventsLeave(in generatorID : String)
when {not self.isSelfLoop()}
{
	self.elaborates[name <> INIT].map event2statemachinesEventLeave(self, generatorID);
}

/*
 * Transforms event to same event augmented with leave actions.
 * Generates leave actions from transition and adds to event.
 */
mapping inout eventb::machine::Event::event2statemachinesEventLeave(in transition : statemachines::Transition, in generatorID : String) {
	self.actions := transition.source.map node2leaveActions(self, transition, generatorID)->
		union(self.actions);
}

/*
 * recurses up the chain of incomers until a real source state is found 
 * then invokes sourceState to leave Actions
 *
 */
mapping statemachines::AbstractNode::node2leaveActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String)  : Bag(eventb::machine::Action) {
	init {
		result := 	self[statemachines::State].map sourceState2leaveActions(event, transition, generatorID)->
		union(self[statemachines::Junction].incoming.source.map node2leaveActions(event, transition, generatorID)->asBag())->
		union(self[statemachines::Fork].incoming.source.map node2leaveActions(event, transition, generatorID)->asBag())->
		union(self[statemachines::Any].map any2leaveActions(event, transition, generatorID)->asBag())
		}
}


mapping statemachines::Any::any2leaveActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := ((self.getStatemachine().getAllStates())-(transition.target.getSuperstates()[statemachines::State])).map sourceState2leaveActions(event,transition,generatorID)
	}
}

/*
 * Transforms source state to leave actions.
 * Generates leave actions for all the superstates of source state, 
 * which are not common to target state's superstates,
 * as well as leave actions for source state's statemachines,
 * excluding parallel statemachines that don't contain target state 
 * if transition is local and is directed from parent state towards its nested state.
 */
mapping statemachines::State::sourceState2leaveActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		var root : statemachines::Statemachine := self.getRootStatemachine();
		switch{
		case (root.translation = statemachines::TranslationKind::SINGLEVAR)
			result := (self.getSuperstates()-(transition.target.getSuperstates()))[statemachines::State].map enum_superState2leaveActions(event, generatorID)->
				union(self.statemachines->reject(transition.isLocalToSource() and not contains(transition.target)).map enum_statemachine2leaveActions(event, generatorID)->asBag())->
				union(self.getRootStatemachine()->reject(not hasExit(transition)).map enum_statemachine2leaveAction(event,generatorID)->asBag());
		case (root.translation = statemachines::TranslationKind::MULTIVAR)
			result := (self.getSuperstates()-(transition.target.getSuperstates()))[statemachines::State].map vars_superState2leaveActions(event, generatorID)->
				union(self.statemachines->reject(transition.isLocalToSource() and not contains(transition.target)).map vars_statemachine2leaveActions(event, generatorID)->flatten()->asBag());
		else
			result := Bag {};
		};

	}
}

