import util;
import libraries.statemachines2events_enter;
import libraries.statemachines2events_leave;

modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

library statemachines2events;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Event guards and actions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms root statemachine to events.
 * Augments events with guards and actions.
 * First generates guards and enter actions, then leave actions (to be able to track for enter actions and avoid multiple action generation on same variable).
 */
mapping statemachines::Statemachine::rootStatemachine2events(in generatorID : String) {
	self.map statemachine2events(generatorID);
	self.map statemachine2eventsLeave(generatorID);
}

/*
 * Transforms statemachine to events.
 * Augments events with guards and enter actions generated from transitions.
 */
mapping statemachines::Statemachine::statemachine2events(in generatorID : String) {
	self.transitions.map transition2events(generatorID);
	self.nodes[statemachines::State].statemachines.map statemachine2events(generatorID);
}

/*
 * Transforms transition to event with guards and enter actions.
 * Generates guards and enter actions for events elaborated by transition.
 * Skips initialisation event.
 */
mapping statemachines::Transition::transition2events(in generatorID : String) {
	self.elaborates[name <> INIT].map event2statemachinesEvent(self, generatorID);
}

/*
 * Transforms event to same event augmented with guard and enter actions.
 * Generates guard and enter actions from transition and adds to event. union(transition.map initialTransition2sourceGuard(self, generatorID)->asOrderedSet())->
 * Skips mapping of enter actions for self-loop transitions.
 */
mapping inout eventb::machine::Event::event2statemachinesEvent(in transition : statemachines::Transition, in generatorID : String) {

	self.parameters := transition.target.getRootStatemachine()[transition.target.getRootStatemachine().instances!=null].map 
						rootStatemachine2parameter(self, generatorID)->union(self.parameters);
						
	self.guards := transition.source[statemachines::State].map sourceState2sourceGuard(self, generatorID)->
		union(transition.map initialTransition2sourceGuard(self, generatorID)->asOrderedSet())->
		union(self.guards);
	
	self.actions := transition[source<>target].target[statemachines::State].map targetState2enterActions(self, transition, generatorID)->
		union(self.actions);
}

mapping statemachines::Statemachine::rootStatemachine2parameter(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Parameter
 when{ self.isRootStatemachine() and not(event.containsParameterWithName(self.selfName)) }
 {
 	name := self.selfName;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
 }


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Source guard
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms source state to source guard.
 * Generates guard for source state and particular event.
 * Skips transformation if event contains source guard on the same state already.
 * If event occurs in more than one transition, generates a disjunctive guard
 */
 /*OLD
 when { not event.extended or not event.containsGuard("isin_" + self.name) } {
	name := ISIN_ + self.name;
	predicate := self.name + B_EQ + B_TRUE;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}*/

mapping statemachines::State::sourceState2sourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 when{ not( event.containsGuardWithPrefix(ISIN_ + self.name) or event.containsGuardWithSuffix(ISIN_ + self.name)) }
 {
	var done : Boolean = false;
/*	DISJUNCTIVE GUARD REMOVED AS DOESN'T WORK
	event.guards->forEach(i){
		//make a disjunctive guard if other transitions elaborate the same event (i.e. have generated a source state guard)
		if(i.isGenerated(generatorID) and (i.name.startsWith(ISIN_) or i.name.startsWith(ISNOTIN_))) then{	// and i.isFromSameSM(self.source)
			name := i.name + "_or_" + ISIN_ + self.name;
			predicate := i.predicate + B_OR + self.getSourceStatePredicate();
			attributes += getGeneratedAttr(generatorID);
			event.guards := event.guards->excluding(i);
			done := true;
		}endif
	};
	*/
	if(done=false)then{
		name := ISIN_ + self.name;
		predicate := self.getSourceStatePredicate();
		generated := true;
		attributes += getGeneratedAttr(generatorID);
	}endif
}

/*
 * Returns a predicate string representing the guard for the transition source state
 * this is either state = TRUE of self : state depending on lifting
 */
helper statemachines::State::getSourceStatePredicate() : String {
	return 
			if self.getRootStatemachine().instances = null
			then self.name + B_EQ + B_TRUE
			else self.getRootStatemachine().selfName+B_IN+self.name
			endif;
}

/*
 * Only for transitions from the root initial state when the root statemachine has a final state
 * Transforms initial transition to guard that the statemachine is not active.
 * Generates guard for source state and particular event.
 * Skips transformation if event contains source guard on the same state already.
 */

mapping statemachines::Transition::initialTransition2sourceGuard(inout event : eventb::machine::Event, in generatorID : String) : eventb::machine::Guard
 when{ self.source.oclIsKindOf(statemachines::Initial) and
 		self.source.getStatemachine().isRootStatemachine() and
 		self.source.getStatemachine().hasFinalState() and
 		not(event.containsGuardWithPrefix(ISNOTIN_ + self.source.getStatemachine().name) or
 			 event.containsGuardWithSuffix(ISNOTIN_ + self.source.getStatemachine().name)) }
 {
	var done : Boolean = false;
/*	DISJUNCTIVE GUARD REMOVED AS DOESN'T WORK
	event.guards->forEach(i){
		//make a disjunctive guard if other transitions elaborate the same event (i.e. have generated a source state guard)
		if(i.isGenerated(generatorID) and (i.name.startsWith(ISIN_) or i.name.startsWith(ISNOTIN_))) then{	// and i.isFromSameSM(self.source)
			name := i.name + "_or_" + ISNOTIN_ + self.source.getStatemachine().name;
			predicate := i.predicate +B_OR+ self.getStateMachineNotActivePredicate();
			generated := true;
			attributes += getGeneratedAttr(generatorID);
			event.guards := event.guards->excluding(i);
			done := true;
		}endif
	};
	*/
	if(done=false)then{
		name := ISNOTIN_ + self.source.getStatemachine().name;
		predicate := self.getStateMachineNotActivePredicate();
		generated := true;
		attributes += getGeneratedAttr(generatorID);
	}endif
}

/*
 * Returns a predicate string representing the guard that the root statemachine being activiated is not already activiated
 * this is either TRUE or self /: union of states depending on lifting
 */
helper statemachines::Transition::getStateMachineNotActivePredicate() : String {
	return 
			if self.source.getRootStatemachine().instances = null
			then B_TRUE+B_NOTIN+(self.source.getStatemachine().getStateNamesAsSingletons()->toString(B_UNION)).parenthesize()
			else self.source.getRootStatemachine().selfName+B_NOTIN+(self.source.getStatemachine().getStateNames()->toString(B_UNION)).parenthesize()
			endif;
}



