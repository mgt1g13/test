import util;

modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

library statemachines2init;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialisation actions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms root abstract statemachine to initialisation actions.
 * Augments initialisation event with actions.
 * First generates active state actions, then inactive state actions (to be able to track active states and don't generate conflicting actions on same state).
 */
mapping statemachines::AbstractStatemachine::rootAbstractStatemachine2initActions(in generatorID : String) {
	self.nodes[statemachines::Initial].outgoing.map transition2initActions(generatorID);
	self.eContainer().oclAsType(eventb::machine::Machine).events[name = INIT].map initEvent2nitEventInactiveStates(self, generatorID);
}

/*
 * Transforms transition to initialisation actions.
 * Generates actions for initialisation event, elaborated by transition.
 */
mapping statemachines::Transition::transition2initActions(in generatorID : String) {
	self.elaborates[name = INIT].map initEvent2initEventActiveStates(self, generatorID);
}

/*
 * Transforms event to same event augmented with initialisation actions on active states.
 * Generates initialisation actions from transition and adds to event.
 */
mapping inout eventb::machine::Event::initEvent2initEventActiveStates(in transition : statemachines::Transition, in generatorID : String) {
	self.actions := transition.target.externalise().map targetAbstractState2initActionsActive(self, generatorID)->
		union(self.actions);
}

/*
 * Transfroms active target abstract state to initialisation actions.
 * Generates actions for all the superstates of target state,
 * as well as actions for target state's statemachines.
 */
mapping statemachines::AbstractState::targetAbstractState2initActionsActive(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.getSuperstates().map superAbstractState2initActionsActive(event, generatorID)->
			union(self.map abstractState2initActionsActive(event, self, generatorID)->asBag());
	}
}

/*
 * Transforms abstract state to initialisation action.
 * Generates action for abstract state and event.
 * Skips transformation if event is extended and contains same action already.
 */
mapping statemachines::AbstractState::abstractState2initAction(in event : eventb::machine::Event, in value : String, in generatorID : String) : eventb::machine::Action
when { not event.extended or not event.containsAction(self.getName() + ".init") } {
	name := self.getName() + ".init";
	action := self.getName() + B_BEQ + value;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Superstate actions (active)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms superstate to initialisation actions.
 * Generates action for abstract state itself and for its statemachines,
 * excluding those which contain a target state of a transition of the same event (so actions will be generated for those from their own transition).
 */
mapping statemachines::AbstractState::superAbstractState2initActionsActive(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map abstractState2initAction(event, B_TRUE, generatorID)->asBag()->
			union(self.statemachines->reject(containsEventTarget(event)).map abstractStatemachine2initActionsActive(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Nested state actions (active)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms active abstract state to initialisation actions.
 * Generates action for abstract state
 * as well as all its statemachines, excluding those containing target state directly linked by transition, so that intermediate statemachines don't need to be initialised.
 */
mapping statemachines::AbstractState::abstractState2initActionsActive(in event : eventb::machine::Event, in target : statemachines::AbstractState, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map abstractState2initAction(event, B_TRUE, generatorID)->asBag()->
			union(self.statemachines[not contains(target)].map abstractStatemachine2initActionsActive(event, generatorID)->flatten()->asBag());
	}
}

/*
 * Transforms active abstract statemachine to initialisation actions.
 * Finds initial state in statemachine (state, linked by transition with Initial state)
 * and generates initialisation actions for all superstates of found initial state,
 * as well as actions for initial state itself and its statemachines.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2initActionsActive(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		var target : statemachines::AbstractState := self.getInitialState();
		result := target.getSuperstatesTo(self).map abstractState2initActionsActive(event, target, generatorID)->flatten()->asBag()->
			union(target.map abstractState2initActionsActive(event, target, generatorID));
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Inactive state actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms event to same event augmented with initialisation actions on inactive states.
 * Generates initialisation actions on inactive states and adds to initialisation event.
 */
mapping inout eventb::machine::Event::initEvent2nitEventInactiveStates(in statemachine : statemachines::AbstractStatemachine, in generatorID : String) {
	self.actions := statemachine.map abstractStatemachine2initActionsInactive(self, generatorID)->
		union(self.actions);
}

/*
 * Transforms abstract statemachine to initialisation actions on inactive states.
 */
mapping statemachines::AbstractStatemachine::abstractStatemachine2initActionsInactive(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.nodes[statemachines::AbstractState].map abstractState2initActionsInactive(event, generatorID)->flatten()->asBag();
	}
}

/*
 * Transforms abstract state to initialisation actions on inactive states.
 * Generates action for abstract state only if no mapping found for the same state, that generated active state initialisation event.
 */
mapping statemachines::AbstractState::abstractState2initActionsInactive(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		var action := self.resolveoneIn(statemachines::AbstractState::abstractState2initAction, eventb::machine::Action);
		result := self[action = null].map abstractState2initAction(event, B_FALSE, generatorID)->
			union(self.statemachines.map abstractStatemachine2initActionsInactive(event, generatorID)->flatten()->asBag());
	}
}