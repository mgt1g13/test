import util;

modeltype eventb uses core('http://emf.eventb.org/models/core/2014');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines/2014');

library statemachines2events_enter;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Target actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms target state to enter actions.
 * Generates enter actions for all the superstates of target state, 
 * which are not common to source state's superstates,
 * as well as enter actions for target state's statemachines,
 * excluding parallel statemachines that don't contain source state 
 * if transition is local and is directed from nested state towards its parent state.
 */
mapping statemachines::State::targetState2enterActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := (self.getSuperstates()-(transition.source.getSuperstates()))[statemachines::State].map superState2enterActions(event, generatorID)->
			union(self.statemachines->reject(transition.isLocalToTarget() and not contains(transition.source)).map statemachine2enterActions(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Superstate actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms superstate to enter actions.
 * Generates enter action for state itself and enter actions for its statemachines,
 * excluding those which contain a target state of some another transition 
 * elaborating same event (so enter actions will be generated for those from their own transition).
 */
mapping statemachines::State::superState2enterActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map state2enterAction(event, generatorID)->asBag()->
			union(self.statemachines->reject(containsEventTarget(event)).map statemachine2enterActions(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Nested state actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms state to enter actions.
 * Generates enter action for state as well as enter actions for its statemachines, 
 * excluding one that contains target state directly linked by transition, 
 * so that intermediate statemachines don't need to be initialised.
 */
mapping statemachines::State::state2enterActions(in event : eventb::machine::Event, in target : statemachines::State, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map state2enterAction(event, generatorID)->asBag()->
			union(self.statemachines[not contains(target)].map statemachine2enterActions(event, generatorID)->flatten()->asBag());
	}
}

/*
 * THIS RULE IS DISABLED - IT USED TO GENERATE ENTER ACTIONS FOR NESTED STATEMACHINES BASED ON ANONYMOUS (I.E. NO ELABORATES) TRANSITIONS
 * HOWEVER THIS IS NOW DONE BY THE USER EXPLICITLY ELABORATING THE INITIAL TRANSITIONS
 * Transforms statemachine to enter actions.
 * Finds starting state in statemachine (state, linked by transition with Initial state)
 * and generates enter actions for all superstates of found state up to current statemachine,
 * as well as enter actions for that state and its statemachines.
 */
mapping statemachines::Statemachine::statemachine2enterActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		//var target : statemachines::State := self.getStartingState();
		result := Bag {} ;
		//target.getSuperstatesTo(self).map state2enterActions(event, target, generatorID)->flatten()->asBag()->
		//	union(target.map state2enterActions(event, target, generatorID));
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Enter action
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms state to enter action.
 * Generates enter action for targeted state and particular event.
 * Skips transformation if event contains enter action on the same state already.
 */
mapping statemachines::State::state2enterAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action 
	when { not event.containsAction(ENTER_ + self.name) }
{
	var root : statemachines::Statemachine := self.getRootStatemachine();
	name := ENTER_ + self.name;
	switch{
	case (root.translation = statemachines::TranslationKind::MULTIVAR)
		action :=
			if root.instances = null then
				self.name+B_BEQ+B_TRUE
			else
				self.name+B_BEQ+self.name+B_UNION+self.getRootStatemachine().selfName.asSet()
			endif;
	case (root.translation = statemachines::TranslationKind::SINGLEVAR)
		action :=
			if root.instances = null then
				self.getStatemachine().name + B_BEQ + self.name
			else
				self.getStatemachine().name+(root.selfName).parenthesize()+B_BEQ+self.name
			endif;
	else
		action := "<Statemachine translation error: unknown translation kind>";
	};
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}
