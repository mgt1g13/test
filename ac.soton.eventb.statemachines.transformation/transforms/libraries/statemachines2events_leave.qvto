import util;

modeltype eventb uses core('http://emf.eventb.org/models/core/2014');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines/2014');

library statemachines2events_leave;

/*
 * Transforms statemachine hierarchy by adding transition leave actions to all elaborated events.
 * Separated from event transformation rules (which generate guards and enter actions) 
 * to be able to track enter actions already generated
 * and avoid generation of leave action if enter action on the same statemachine exists.
 */
mapping statemachines::Statemachine::statemachine2eventsLeave(in generatorID : String) {
	self.transitions.map transition2eventsLeave(generatorID);
	self.nodes[statemachines::State].statemachines.map statemachine2eventsLeave(generatorID);
}

/*
 * Transforms transition to event with leave actions.
 * Generates leave actions for events elaborated by transition.
 * Skips initialisation event.
 */
mapping statemachines::Transition::transition2eventsLeave(in generatorID : String)
when {not self.isSelfLoop()}
{
	self.elaborates[name <> INIT].map event2statemachinesEventLeave(self, generatorID);
}

/*
 * Transforms event to same event augmented with leave actions.
 * Generates leave actions from transition and adds to event.
 */
mapping inout eventb::machine::Event::event2statemachinesEventLeave(in transition : statemachines::Transition, in generatorID : String) {
	self.actions := transition.source[statemachines::State].map sourceState2leaveActions(self, transition, generatorID)->
		union(self.actions);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Leave action
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms state to leave action.
 * Generates leave action for source state and particular event.
 * Skips transformation if enter action on the same state exists
 * or if event is extended and contains leave action on the same state already.
 */
mapping statemachines::State::state2leaveAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action 
	when { not event.containsAction(ENTER_ + self.name) 
		and not event.containsAction(LEAVE_ + self.name) }
{
	name := LEAVE_ + self.name;
	if (self.getRootStatemachine().instances = null) then {
		action := self.name+B_BEQ+B_FALSE;
	}else{
		action := self.name+B_BEQ+self.name+B_SETMINUS+self.getRootStatemachine().selfName.asSet();
	}endif;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Source actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms source state to leave actions.
 * Generates leave actions for all the superstates of source state, 
 * which are not common to target state's superstates,
 * as well as leave actions for source state's statemachines,
 * excluding parallel statemachines that don't contain target state 
 * if transition is local and is directed from parent state towards its nested state.
 */
mapping statemachines::State::sourceState2leaveActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := (self.getSuperstates()-(transition.target.getSuperstates()))[statemachines::State].map superState2leaveActions(event, generatorID)->
			union(self.statemachines->reject(transition.isLocalToSource() and not contains(transition.target)).map statemachine2leaveActions(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Superstate actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms superstate to leave actions.
 * Generates leave action for state itself and leave actions for its statemachines,
 * excluding those which contain a source state of some another transition elaborating same event 
 * (so leave actions will be generated for those from their own transition).
 */
mapping statemachines::State::superState2leaveActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map state2leaveAction(event, generatorID)->asBag()->
			union(self.statemachines->reject(containsEventSource(event)).map statemachine2leaveActions(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Nested state actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to leave actions.
 * Generates leave actions for all states of statemachine.
 */
mapping statemachines::Statemachine::statemachine2leaveActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.nodes[statemachines::State].map state2leaveActions(event, generatorID)->asBag();
	}
}


/*
 * Transforms state to leave actions.
 * Generates leave action for state
 * as well as leave actions for its statemachines.
 */
mapping statemachines::State::state2leaveActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map state2leaveAction(event, generatorID)->asBag()->
			union(self.statemachines.map statemachine2leaveActions(event, generatorID)->flatten()->asBag());
	}
}

