import util;

modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

library set_statemachines2invariants;
property refinmentLevel : Integer = 0; 	
property RootStatemachine : Statemachine = null;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Type invariants
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to type invariants.
 */
mapping statemachines::Statemachine::statemachine2typeInvariants(in generatorID : String, in refLevel : Integer, inout machine : eventb::machine::Machine) : Sequence(eventb::machine::Invariant) {
	init {
  		refinmentLevel := refLevel;	
  		RootStatemachine := self;
  		//delete all type invariants that are generated by the statemachine
	machine.invariants -> forEach(i){
		if(i.name = TYPEOF_ + self.name + "_" + refinmentLevel.toString())then{							//have to try it with more than one statemachines
			machine.invariants := machine.invariants->excluding(i);
		}endif;
	};
		result := self.map statemachine2typeInvariant(generatorID,machine)->asSequence();
	}
}

/*
 * Transforms statemachine to type invariant.
 * Creates invariant only for non-refined statemachine.
 */
mapping statemachines::Statemachine::statemachine2typeInvariant(in generatorID : String, inout machine : eventb::machine::Machine) : eventb::machine::Invariant 
	
{	  
	name := TYPEOF_ + self.name + "_" + refinmentLevel.toString();
	predicate := self.name + "_" + refinmentLevel.toString() + B_IN + "\u2119" + (self.name + _STATES).parenthesize();
	generated := true;
	attributes += getGeneratedAttr(generatorID);

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Superstate invariants
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to superstate invariants.
 */
mapping statemachines::Statemachine::statemachine2superstateInvariants(in generatorID : String, inout machine : eventb::machine::Machine) : Sequence(eventb::machine::Invariant) {
	init {
	
		result := self[statemachines::State].map state2superstateInvariants(generatorID,machine)-> asSequence()-> union(self.nodes[statemachines::State].map state2superstateInvariants(generatorID,machine));
	}
}

/*
 * Transforms state to superstate invariants.
 */
mapping statemachines::State::state2superstateInvariants(in generatorID : String, inout machine : eventb::machine::Machine) : Sequence(eventb::machine::Invariant) 

{

	init {
	machine.invariants -> forEach(i){
		if(i.isGenerated(generatorID))then{							//have to try it with more than one statemachines
			machine.invariants := machine.invariants->excluding(i);
		}endif;
	};
	
		result := self.map statemachine2superstateInvariant(self, generatorID,machine)->asSequence()->
	        union(self.statemachines.map statemachine2superstateInvariants(generatorID,machine));
	}
}

/*
 * Transforms statemachine to partition invariant.
 * Creates invariant only for non-refined statemachine.
 */
mapping statemachines::State::statemachine2superstateInvariant(in parentState : statemachines::State, in generatorID : String, inout machine : eventb::machine::Machine) : eventb::machine::Invariant
when{refinmentLevel > 0}
{
   machine.invariants->forEach(i){
   	if(i.name = "valueof_" + RootStatemachine.name + "_" + refinmentLevel.toString())then{
   		machine.invariants := machine.invariants->excluding(i);	
   	}
   	endif
   };
   if(self.getStatemachine().hasParentState()) then {
	name := self.name + "_Invariant";
	predicate := RootStatemachine.name + "_" + refinmentLevel.toString() + B_EQ + self.name + B_IMPL + RootStatemachine.name + "_" + (refinmentLevel-1).toString() + B_EQ + self.getStatemachine().getSuperState().name;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
	}
	else{
	name := self.name + "_Invariant";
	predicate := RootStatemachine.name + "_" + refinmentLevel.toString() + B_EQ + self.name + B_IMPL + RootStatemachine.name + "_" + (refinmentLevel-1).toString() + B_EQ + self.name;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
	}
	endif
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Constraint invariants
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms statemachine to constraint invariants.
 */
mapping statemachines::Statemachine::statemachine2constraintInvariants(in generatorID : String) : Sequence(eventb::machine::Invariant) {
	init {
		result := self.nodes[statemachines::State].map state2constraintInvariants(generatorID);
	}
}

/*
 * Transforms state to constraint invariants.
 */
mapping statemachines::State::state2constraintInvariants(in generatorID : String) : Sequence(eventb::machine::Invariant) {
	init {
		result := self.map state2constraintInvariantsFinal(generatorID)->asSequence()->
			union(self.statemachines.nodes[statemachines::State].map state2constraintInvariants(generatorID)->flatten());
	}
}

/*
 * Transforms state to constraint invariants.
 */
mapping statemachines::State::state2constraintInvariantsFinal(in generatorID : String) : Sequence(eventb::machine::Invariant) {
	init {
		result := self.invariants->collect(i | object eventb::machine::Invariant {
			name := i.name;
			theorem := i.theorem;
			predicate := (RootStatemachine.name + "_" + refinmentLevel.toString() + B_IN + self.name).parenthesize() + B_IMPL + i.predicate.parenthesize();
			generated := true;
			attributes += getGeneratedAttr(generatorID);
		});
	}
}