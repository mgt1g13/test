import util;

modeltype eventb uses core('http://emf.eventb.org/models/core');
modeltype statemachines uses statemachines('http://soton.ac.uk/models/eventb/statemachines');

library set_statemachines2events_enter;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Enter action
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms state to enter action.
 * Generates enter action for targeted state and particular event.
 * Skips transformation if event contains enter action on the same state already.
 */
mapping statemachines::State::state2enterAction(in event : eventb::machine::Event, in generatorID : String) : eventb::machine::Action 
	when { not event.containsActionWithPrefix("enter_" + self.getStatemachine().name) }
{
	name := ENTER_ + self.getStatemachine().name + "__" + self.name;
	action := self.getStatemachine().name + B_BEQ + self.name;
	generated := true;
	attributes += getGeneratedAttr(generatorID);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Target actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms target state to enter actions.
 * Generates enter actions for all the superstates of target state, 
 * which are not common to source state's superstates,
 * as well as enter actions for target state's statemachines,
 * excluding parallel statemachines that don't contain source state 
 * if transition is local and is directed from nested state towards its parent state.
 */
mapping statemachines::State::targetState2enterActions(in event : eventb::machine::Event, in transition : statemachines::Transition, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := (self.getSuperstates()-(transition.source.getSuperstates()))[statemachines::State].map superState2enterActions(event, generatorID)->
			union(self.statemachines->reject(transition.isLocalToTarget() and not contains(transition.source)).map statemachine2enterActions(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Superstate actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms superstate to enter actions.
 * Generates enter action for state itself and enter actions for its statemachines,
 * excluding those which contain a target state of some another transition 
 * elaborating same event (so enter actions will be generated for those from their own transition).
 */
mapping statemachines::State::superState2enterActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map state2enterAction(event, generatorID)->asBag()->
			union(self.statemachines->reject(containsEventTarget(event)).map statemachine2enterActions(event, generatorID)->flatten()->asBag());
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Nested state actions
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
 * Transforms state to enter actions.
 * Generates enter action for state as well as enter actions for its statemachines, 
 * excluding one that contains target state directly linked by transition, 
 * so that intermediate statemachines don't need to be initialised.
 */
mapping statemachines::State::state2enterActions(in event : eventb::machine::Event, in target : statemachines::State, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		result := self.map state2enterAction(event, generatorID)->asBag()->
			union(self.statemachines[not contains(target)].map statemachine2enterActions(event, generatorID)->flatten()->asBag());
	}
}

/*
 * Transforms statemachine to enter actions.
 * Finds starting state in statemachine (state, linked by transition with Initial state)
 * and generates enter actions for all superstates of found state up to current statemachine,
 * as well as enter actions for that state and its statemachines.
 */
mapping statemachines::Statemachine::statemachine2enterActions(in event : eventb::machine::Event, in generatorID : String) : Bag(eventb::machine::Action) {
	init {
		var target : statemachines::State := self.getStartingState();
		result := target.getSuperstatesTo(self).map state2enterActions(event, target, generatorID)->flatten()->asBag()->
			union(target.map state2enterActions(event, target, generatorID));
	}
}
